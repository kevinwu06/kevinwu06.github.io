<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿谦</title>
  
  <subtitle>你若安好，便是晴天</subtitle>
  <link href="https://www.kevinwu.cc/atom.xml" rel="self"/>
  
  <link href="https://www.kevinwu.cc/"/>
  <updated>2024-02-26T12:27:32.578Z</updated>
  <id>https://www.kevinwu.cc/</id>
  
  <author>
    <name>阿谦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《原子习惯》阅读笔记</title>
    <link href="https://www.kevinwu.cc/posts/AtomicHabits/"/>
    <id>https://www.kevinwu.cc/posts/AtomicHabits/</id>
    <published>2023-11-23T08:07:26.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="小习惯的大力量"><a href="#小习惯的大力量" class="headerlink" title="小习惯的大力量"></a>小习惯的大力量</h2><p>一个微小的习惯改变，会对未来影响很大。<br>每天进步1%，一年就是很多。<br>专注于系统，而不是目标。</p><h2 id="基于身份的习惯比基于目标的习惯更有效"><a href="#基于身份的习惯比基于目标的习惯更有效" class="headerlink" title="基于身份的习惯比基于目标的习惯更有效"></a>基于身份的习惯比基于目标的习惯更有效</h2><ol><li>自己想成为什么样的人</li><li>用习惯去证明自己是这样的人</li></ol><h2 id="习惯形成的4个步骤："><a href="#习惯形成的4个步骤：" class="headerlink" title="习惯形成的4个步骤："></a>习惯形成的4个步骤：</h2><blockquote><p><strong>提示，渴望，反应，奖励。</strong></p></blockquote><p><code>例子</code>：你起床(提示)，想要清醒(渴望)，所以喝了杯咖啡(反应)，满足了清醒的需求(奖励)。</p><p><strong>建立好习惯</strong>：让提示更明显，让渴望更吸引，让反应更简单，让奖励更令人满意。<br><strong>打破坏习惯</strong>：让提示不明显，让渴望不吸引，让反应更困难，让奖励更令人不满。</p><h1 id="1st-law—让提示更明显"><a href="#1st-law—让提示更明显" class="headerlink" title="1st law—让提示更明显"></a>1st law—让提示更明显</h1><h2 id="加强对习惯的意识"><a href="#加强对习惯的意识" class="headerlink" title="加强对习惯的意识"></a>加强对习惯的意识</h2><p><strong>写习惯清单</strong>：把自己现有的习惯全写上去，并做好坏评估。</p><p><strong>Pointing-and-calling</strong>：把自己接下来要做的事和结果大声说出来。这样可以增强意识。</p><blockquote><p><code>例子</code>：</p><ul><li>“明天五点我要去邮政局”</li><li>“我现在要吃饼干，但是我并不需要，这会让我变胖。”</li></ul></blockquote><h2 id="让提示更明显的两个方法"><a href="#让提示更明显的两个方法" class="headerlink" title="让提示更明显的两个方法"></a>让提示更明显的两个方法</h2><blockquote><p><strong>Implementation intension(执行意向)公式</strong>：“I will [BEHAVIOR] at [TIME] in [LOCATION].”</p><p><strong>Habit stacking(习惯堆叠)公式</strong>：“After [CURRENT HABIT], I will [NEW HABIT].”</p></blockquote><h2 id="环境比动力更重要"><a href="#环境比动力更重要" class="headerlink" title="环境比动力更重要"></a>环境比动力更重要</h2><p><strong>让好习惯的提示更明显</strong>：</p><ul><li><p>把要阅读的书放在桌子上显眼的地方</p></li><li><p>把游戏手柄放隐蔽的地方</p></li></ul><p><strong>给特定环境关联特定习惯</strong>：</p><ul><li>在床上就睡觉，在桌上就学习</li></ul><p>（尽量给一个环境只关联一个习惯）</p><h2 id="借助环境远离坏习惯"><a href="#借助环境远离坏习惯" class="headerlink" title="借助环境远离坏习惯"></a>借助环境远离坏习惯</h2><p>依靠自控力只是一个短期的方法，我们需要环境配合才能更长久，要<strong>远离坏习惯的提示</strong>。</p><blockquote><p><code>例子</code>：</p><ul><li>写作业效率不高，就把手机放在另一个房间一段时间。</li><li>花钱买太多东西，就不要刷淘宝。</li><li>老玩游戏，就把手柄放在看不到的地方。</li></ul></blockquote><h1 id="2nd-law-让它更吸引"><a href="#2nd-law-让它更吸引" class="headerlink" title="2nd law 让它更吸引"></a>2nd law 让它更吸引</h1><h2 id="诱惑捆绑"><a href="#诱惑捆绑" class="headerlink" title="诱惑捆绑"></a>诱惑捆绑</h2><p>把需要做的和想做的事关联起来</p><blockquote><p><strong>habit stacking + temptation bundling公式</strong>:<br>After [CURRENT HABIT], I will [HABIT I NEED].<br>After [HABIT I NEED], I will [HABIT I WANT].</p></blockquote><h2 id="加入好的圈子"><a href="#加入好的圈子" class="headerlink" title="加入好的圈子"></a>加入好的圈子</h2><p>加入你想建立的习惯在他们之中是常态的圈子，我们会被所处圈子影响</p><p>找到你和圈子中的人的相同特征，这会让你有归属感</p><h2 id="激励仪式"><a href="#激励仪式" class="headerlink" title="激励仪式"></a>激励仪式</h2><p>创造一个激励仪式在困难习惯之前做，给好习惯关联上积极的情感。</p><blockquote><p><code>例子</code>：每次玩游戏前深呼吸然后笑，之后在写作业前也这样做。</p></blockquote><h1 id="3rd-law-让它更简单"><a href="#3rd-law-让它更简单" class="headerlink" title="3rd law 让它更简单"></a>3rd law 让它更简单</h1><h2 id="开始行动，不断重复习惯，不要纸上谈兵"><a href="#开始行动，不断重复习惯，不要纸上谈兵" class="headerlink" title="开始行动，不断重复习惯，不要纸上谈兵"></a>开始行动，不断重复习惯，不要纸上谈兵</h2><p>调整环境，让习惯更简单。<strong>每次做完习惯之后，都为下一次习惯做好准备</strong>。</p><blockquote><p><code>例子</code>：</p><ul><li>想健身，提前把装备准备好。</li><li>想写作业，提前把作业放在桌上。</li><li>玩游戏，就把手柄锁柜子里。</li></ul></blockquote><h2 id="善用决定性时刻，用小行为决定走向。"><a href="#善用决定性时刻，用小行为决定走向。" class="headerlink" title="善用决定性时刻，用小行为决定走向。"></a>善用决定性时刻，用小行为决定走向。</h2><p>当你穿上了跑鞋，就说明你决定了你接下来会去跑步。</p><p>这会减少拖延和犹豫。</p><h2 id="两分钟规则"><a href="#两分钟规则" class="headerlink" title="两分钟规则"></a>两分钟规则</h2><ol><li>简化习惯，所有习惯都能简化成在两分钟内完成的形式。</li><li>建立起习惯后，再去提升时长和质量。</li></ol><blockquote><p>例子：</p><ul><li>每天读一页书。</li><li>穿上跑步鞋。</li></ul></blockquote><h2 id="自动化你的习惯"><a href="#自动化你的习惯" class="headerlink" title="自动化你的习惯"></a>自动化你的习惯</h2><p>投资<strong>锁定未来行为</strong>的技术和一次性购买。</p><p><code>例子</code>：买健身房卡，这会迫使你未来常去锻炼。</p><h1 id="4th-law-让它更令人开心"><a href="#4th-law-让它更令人开心" class="headerlink" title="4th law 让它更令人开心"></a>4th law 让它更令人开心</h1><h2 id="即使奖励"><a href="#即使奖励" class="headerlink" title="即使奖励"></a>即使奖励</h2><p>给好习惯<strong>增加立即能获得的奖励</strong>，给坏习惯<strong>增加立即会得到的惩罚</strong>。</p><blockquote><p><code>The Cardinal Rule of Behavior Change</code>: </p><p>What is immediately rewarded is repeated. What is immediately punished is avoided.</p></blockquote><p><code>例子</code>：记账“去旅游”，每少吃一次大餐就往里存50元。</p><h2 id="视觉化进度"><a href="#视觉化进度" class="headerlink" title="视觉化进度"></a>视觉化进度</h2><p><strong>视觉化习惯的完成进度</strong>，增加每次做完后的成就感</p><p><code>例子</code>：健身记录，读书页码，读书打卡</p><blockquote><p><strong>Habit Tracking(习惯记录)</strong></p><p>The habit stacking + habit tracking公式:</p><p>After [CURRENT HABIT], I will [TRACK MY HABIT].”</p></blockquote><p>注意：不要因过度重视记录的次数，而忽略了习惯的质量和本身的目的。</p><h2 id="习惯中断要立即重拾"><a href="#习惯中断要立即重拾" class="headerlink" title="习惯中断要立即重拾"></a>习惯中断要立即重拾</h2><p>不要连续缺勤两次，习惯<strong>中断要立即重拾</strong></p><h2 id="习惯违反合同"><a href="#习惯违反合同" class="headerlink" title="习惯违反合同"></a>习惯违反合同</h2><p>找一个搭档，监督你的行为。</p><p>建立习惯合同，让违反承诺的代价变得公开和痛苦。</p><h1 id="高级策略"><a href="#高级策略" class="headerlink" title="高级策略"></a>高级策略</h1><h2 id="选择适合自己的习惯"><a href="#选择适合自己的习惯" class="headerlink" title="选择适合自己的习惯"></a>选择适合自己的习惯</h2><p>每个人都有自己的人格，有自己适合做的事情，要<strong>取长补短</strong>。</p><p><strong>选择适合自己的习惯</strong>，会更好坚持。</p><h2 id="忍受无聊"><a href="#忍受无聊" class="headerlink" title="忍受无聊"></a>忍受无聊</h2><p>成功在于能<strong>忍受无聊</strong>。</p><p>任何人在感到有动力时都可以努力工作。只有在<strong>没有动力</strong>的时候，还能<strong>坚持下去</strong>，才会超越他人。</p><h2 id="习惯的弊端"><a href="#习惯的弊端" class="headerlink" title="习惯的弊端"></a>习惯的弊端</h2><p>养成习惯之后，很容易<strong>停止去思考和提升</strong>。</p><p>我们要定期<strong>做反思和回顾</strong>，时刻注意自己的表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;小习惯的大力量&quot;&gt;&lt;a href=&quot;#小习惯的大力量&quot; class=&quot;headerlink&quot; title=&quot;小习惯的大力量&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书" scheme="https://www.kevinwu.cc/articles/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何优化Hexo的网站性能？</title>
    <link href="https://www.kevinwu.cc/posts/performance/"/>
    <id>https://www.kevinwu.cc/posts/performance/</id>
    <published>2023-10-11T04:06:31.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>对一个网站来说，性能是非常重要的，它决定了用户在网页停留的时长。</p><p>如果网页的加载速度很慢的话，用户很容易就会离去。</p><p>有朋友说我的博客速度挺快的，这篇文章就讲讲我是如何<strong>优化我的网站性能</strong>的。</p><h1 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h1><p>首先我们可以使用网站性能检测工具，来获取网站的性能报告，这样我们就可以知道是哪部分拖慢了网站速度，从而对其进行优化。</p><p>我用的工具是<strong>Chrome开发者工具</strong>中自带的<strong>Lighthouse</strong>，给出性能报告的同时，它还会给出一些优化的建议。</p><p><img src="https://bed.kevinwu.cc/img/lighthouse.webp" alt="lighthouse"/></p><h1 id="Vercel网站托管"><a href="#Vercel网站托管" class="headerlink" title="Vercel网站托管"></a>Vercel网站托管</h1><p>我使用的是<a href="https://vercel.com/dashboard">Vercel</a>来托管我的网站，它在全球以及国内都有非常优秀的速度。如果想要让其在国内可以浏览的话，需要准备一个域名。</p><blockquote><p>具体如何使用可以参考<a href="https://www.fomal.cc/">Fomalhaut</a>的文章<a href="https://www.fomal.cc/posts/4aa2d85f.html">Hexo博客搭建基础教程(二)</a>中有详细教程。</p></blockquote><p><code>注意</code>：cname的解析方法目前会导致无法在国内访问，需要做一些修改<br><strong>失效方法：</strong>记录值类型cname，值为cname.vercel-dns.com<br><strong>解决方法：</strong>记录值类型A类型，值为76.223.126.88</p><p><img src="https://bed.kevinwu.cc/img/jiexi.webp" alt="解析记录" /></p><h1 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h1><p>在我们的博客中，最消耗流量的应该就是图片了。所以为了提升加载速度，对图片的压缩非常重要。</p><p>1.每次将图片上传到图床之前，我都会对其进行压缩（控制在100kb以下）</p><p>2.同时，将图片转换成webp格式也会大大提高加载速度。</p><blockquote><p>这里推荐一个我一直在用的<a href="https://imagestool.com/webp2jpg-online/">多功能在线图片压缩</a>工具，非常方便快捷。</p></blockquote><p>可以看到，我的图床上目前有100多张图，占用大小总共才4mb。</p><p>有些人可能一张图的大小就占了4mb，网站的加载速度可想而知。</p><p><img src="https://bed.kevinwu.cc/img/bedsize.webp" alt="图床大小" style="zoom:60%;" /></p><h1 id="lazyload"><a href="#lazyload" class="headerlink" title="lazyload"></a>lazyload</h1><p><strong>lazyload(懒加载)</strong>是一个对提升性能非常有效的功能，它会优先加载处于屏幕显示区域内的资源，而不是等待一整个页面的资源加载完毕。这让许多资源可以在用户边浏览的时候边加载，节省时间。</p><p>我给我的评论模块开启了lazyload，因为很多时候评论模块加载都会慢，导致用户要在加载页面等待。</p><h1 id="gulp压缩"><a href="#gulp压缩" class="headerlink" title="gulp压缩"></a>gulp压缩</h1><p><a href="https://www.gulpjs.com.cn/">gulp插件</a>可以帮助我们自动压缩博客静态资源。</p><blockquote><p>具体如何安装使用可以参考<a href="https://akilar.top/">Akilar</a>的文章<a href="https://akilar.top/posts/49b73b87/">【使用gulp压缩博客静态资源】</a></p></blockquote><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>让所有的静态资源通过<strong>CDN(内容分发网络)</strong>加载，可以提高资源加载速度。</p><blockquote><p>我使用的是<a href="https://blog.zhheo.com/">HEO</a>大佬分享的<a href="https://blog.zhheo.com/p/790087d9.html">【Butterfly CDN链接更改指南】</a>中给出的cdn</p></blockquote><p>这里给出我在butterfly中的cdn列表：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="string">https://lib.baomitu.com/pjax/0.2.8/pjax.min.js</span></span><br><span class="line"><span class="attr">twikoo:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js</span></span><br><span class="line"><span class="attr">sharejs:</span> <span class="string">https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js</span></span><br><span class="line"><span class="attr">sharejs_css:</span> <span class="string">https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js</span></span><br><span class="line"><span class="attr">instantpage:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js</span></span><br><span class="line"><span class="attr">typed:</span> <span class="string">https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js</span></span><br><span class="line"><span class="attr">snackbar_css:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css</span></span><br><span class="line"><span class="attr">snackbar:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css</span></span><br><span class="line"><span class="attr">justifiedGallery_js:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js</span></span><br><span class="line"><span class="attr">justifiedGallery_css:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/css/justifiedGallery.min.css</span></span><br><span class="line"><span class="attr">aplayer_css:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css</span></span><br><span class="line"><span class="attr">aplayer_js:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js</span></span><br><span class="line"><span class="attr">meting_js:</span> <span class="string">https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些大概就是我对我的网站做的优化总结了，其实还有很多地方可以再提升，但是对我来说已经够用了。</p><p>希望大家都可以积极地去优化网站的性能，这样才可以收获更多的游客🙂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对一个网站来说，性能是非常重要的，它决定了用户在网页停留的时长。&lt;/p&gt;
&lt;p&gt;如果网页的加载速度很慢的话，用户很容易就会离去。&lt;/p&gt;
&lt;p&gt;有朋友说我的博客速度挺快的，这篇文章就讲讲我是如何&lt;strong&gt;优化我的网站性能&lt;/strong&gt;的。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="博客相关" scheme="https://www.kevinwu.cc/articles/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="博客" scheme="https://www.kevinwu.cc/articles/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://www.kevinwu.cc/articles/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【小科普】你知道编码是怎么来的吗？</title>
    <link href="https://www.kevinwu.cc/posts/code/"/>
    <id>https://www.kevinwu.cc/posts/code/</id>
    <published>2023-09-07T00:13:19.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有想过我们现在的编码是有何而来的？</p><p>这周看了一本非常好的书<strong>《密码了不起》</strong>，通过非常有趣的方式了解了编码的由来。</p><p>来看看我们熟悉的编码格式都是怎么来的吧！</p><h2 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h2><p>18世纪，科学家发现可以<strong>用静电实现远距离通信</strong>，但是电信号只有“连通”和“断开”两种状态，那么要如何通过他们传递信息呢？</p><p>于是科学家发明了<strong>“摩尔斯电码”</strong>这个方案。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>用“点·”和“划-”的不同组合方式来表示我们的字符。</p><blockquote><p>比如：“·-”表示A，“-···”表示B</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是，这个方法的问题是，每个字符所对应的摩尔斯电码长度不同，很容易因为<strong>分割位置不同</strong>产生<strong>多种解码结果</strong>，产生歧义。</p><h2 id="波特码"><a href="#波特码" class="headerlink" title="波特码"></a>波特码</h2><p>于是，当然就有更先进的编码方式来取代了，那就是<strong>“波特码”</strong>。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>固定使用5个“0”和“1”的组合表示一个字符</p><blockquote><p>比如：10000表示A，00110表示B</p></blockquote><p>到这里，我们就可以看到<strong>计算机的影子</strong>了：</p><p>计算机<strong>只能识别“0”和“1”</strong>，不论什么文件都会转化成“0”和“1”在电脑中储存、处理。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>问题又来了，5个为一组的“0”和“1”，总共有2^5^(32)个不同的组合方法，它们<strong>能够表示的字符太少了</strong>。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>为了让波特码表示更多字符，波特对波特码进行了优化，成为了后来的<strong>“ASCII码”</strong>。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>固定使用7个“0”和“1”的组合表示一个字符</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>能表示的字符数量还是不够，只能表示英语，<strong>无法表示其他国家的语言字符</strong>。</p><h2 id="各国编码标准"><a href="#各国编码标准" class="headerlink" title="各国编码标准"></a>各国编码标准</h2><p>各个国家开始制定了<strong>支持自己语言字符</strong>的编码标准。</p><blockquote><p>比如：Latin/Greek编码用8个“0”和“1”的组合表示一个字符，中文编码标准用16个“0”和“1”的组合表示一个字符…</p></blockquote><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>各国用自己的标准，必定会产生<strong>全球信息交流的障碍</strong>，不同国家间流传的文本可能会在另一方变成乱码。</p><h2 id="Unicode-amp-UTF"><a href="#Unicode-amp-UTF" class="headerlink" title="Unicode&amp;UTF"></a>Unicode&amp;UTF</h2><p>于是，在互联网时代，一个<strong>全球统一</strong>的编码标准当然就来了<strong>“Unicode”</strong>。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>规定使用8个“0”和“1”表示英语字母，16个表示汉字，24个表示emoji。</p><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>如何知道什么时候8个为一组，什么时候16个为一组呢？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>科学家进一步提出了<strong>统一编码变换格式(UTF)</strong>的标准来解决。</p><p>UTF标准包含UTF-8, UTF-16, UTF-32三种格式。</p><hr><h2 id="Base16-32-64"><a href="#Base16-32-64" class="headerlink" title="*Base16, 32, 64"></a>*Base16, 32, 64</h2><p>这是用于将计算机中的信息（显示不出来的“0”和“1”）转换成人类能看见的字符的方法。</p><blockquote><p>比如：将一个图片转换成一串字符，用于复制粘贴。</p><p>我们经常在浏览器地址栏看到结尾是一串乱码，实际那就是用Base64url表示的。</p></blockquote><h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ul><li>Base16：将“0”和“1”每4个分为一组，总共可以用2^4^=16个字符来表示。</li><li>Base32：将“0”和“1”每4个分为一组，总共可以用2^5^=32个字符来表示。</li><li>Base64：将“0”和“1”每4个分为一组，总共可以用2^6^=64个字符来表示。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些知识总结于<strong>《密码了不起》</strong>中<strong>讲编码的一部分</strong>，但编码并不是密码，编码只需<strong>掌握规律格式</strong>就可以轻松解出。</p><p>这本书中主要科普了<strong>密码学</strong>这个有趣的方向，大家可以在放松时偷闲一读，非常有意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你有没有想过我们现在的编码是有何而来的？&lt;/p&gt;
&lt;p&gt;这周看了一本非常好的书&lt;strong&gt;《密码了不起》&lt;/strong&gt;，通过非常有趣的方式了解了编码的由来。&lt;/p&gt;
&lt;p&gt;来看看我们熟悉的编码格式都是怎么来的吧！&lt;/p&gt;
&lt;h2 id=&quot;摩尔斯电码&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书" scheme="https://www.kevinwu.cc/articles/tags/%E4%B9%A6/"/>
    
    <category term="编码" scheme="https://www.kevinwu.cc/articles/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>摆脱3DM启动器打开游戏：避免捆绑下载笑傲江湖</title>
    <link href="https://www.kevinwu.cc/posts/3dm/"/>
    <id>https://www.kevinwu.cc/posts/3dm/</id>
    <published>2023-06-06T14:15:15.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>经常白嫖游戏的小伙伴应该都对<a href="https://www.3dmgame.com/">3DM</a>不陌生，里面有很多盗版游戏资源。但是呢，很多3dm下来的游戏都要用3dm启动器去打开，你说用你启动器打开就算了，就多点两下的事对吧。但是每次打开你启动器，你都要下载个“笑傲江湖”到我电脑里，删了还没用，下次启动的时候又会跳出来，这跟流氓软件有什么区别。今天就教大家怎么摆脱3DM流氓启动器，直接打开游戏。</p><p><img src="https://bed.kevinwu.cc/img/xiaoao.webp" /></p><p>首先我们打开3dm启动器目录，如图，打开<code>3dmConfig.ini</code>文件，找到游戏exe文件的路径。</p><p><img src="https://bed.kevinwu.cc/img/3dmpath.webp"/></p><p>接下来我们顺着路径去寻找，会发现根本就找不到游戏的exe文件。别慌，这是3dm耍的小把戏，把游戏启动的exe文件给隐藏了。我们要做的就是把被隐藏的文件给显示出来。</p><p>我们打开cmd窗口，进入对应的目录，然后执行dos命令：</p><blockquote><p>如何打开cmd窗口？win+r，然后输入cmd，点确定</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib -s -a -h -r wwzRetailEgs.exe</span><br></pre></td></tr></table></figure><p><img src="https://bed.kevinwu.cc/img/cmd.webp"/></p><p>然后我们就能看到游戏的exe文件在目录中显示出来了，我们可以右键然后将快捷方式创建到桌面，之后我们就不需要用3dm启动器来打开游戏了😎。</p><p><img src="https://bed.kevinwu.cc/img/3dmexe.webp"/></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经常白嫖游戏的小伙伴应该都对&lt;a href=&quot;https://www.3dmgame.com/&quot;&gt;3DM&lt;/a&gt;不陌生，里面有很多盗版游戏资源。但是呢，很多3dm下来的游戏都要用3dm启动器去打开，你说用你启动器打开就算了，就多点两下的事对吧。但是每次打开你启动器，你都要下</summary>
      
    
    
    
    <category term="游戏娱乐" scheme="https://www.kevinwu.cc/articles/categories/%E6%B8%B8%E6%88%8F%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="游戏" scheme="https://www.kevinwu.cc/articles/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="干货" scheme="https://www.kevinwu.cc/articles/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL教学 | 3.如何给形状添加纹理，绘制各种带图案的形状？</title>
    <link href="https://www.kevinwu.cc/posts/OpenGL3/"/>
    <id>https://www.kevinwu.cc/posts/OpenGL3/</id>
    <published>2023-05-30T10:33:42.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将学习OpenGL中关于纹理的各种知识。纹理就是图片，用于给模型添加细节。</p><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><p>如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像。下面更多的选择：</p><div class="table-container"><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table></div><p>设置坐标轴环绕方式（s、t（如果是使用3D纹理那么还有一个r））</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><p>如果选择GL_CLAMP_TO_BORDER选项，需要指定一个边缘的颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><p>如何将<strong>纹理像素</strong>(Texture Pixel)映射到纹理坐标，让分辨率清晰</p><p>纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：</p><h3 id="GL-NEAREST"><a href="#GL-NEAREST" class="headerlink" title="GL_NEAREST"></a>GL_NEAREST</h3><p>邻近过滤 (Nearest Neighbor Filtering):</p><p>选择中心点最接近纹理坐标的那个像素</p><p><img src="https://learnopengl-cn.github.io/img/01/06/filter_nearest.png" alt="img"></p><h3 id="GL-LINEAR"><a href="#GL-LINEAR" class="headerlink" title="GL_LINEAR"></a>GL_LINEAR</h3><p>线性过滤 (linear Filtering):</p><p>基于纹理坐标附近的纹理像素，计算出一个插值 (心距离纹理坐标越近,贡献越大)</p><p><img src="https://learnopengl-cn.github.io/img/01/06/filter_linear.png" alt="img"></p><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p><img src="https://learnopengl-cn.github.io/img/01/06/texture_filtering.png" alt="img"></p><p>我们可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h1 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h1><p>(Mipmap)：一系列的纹理图像，后一个纹理图像是前一个的二分之一。</p><p>功能：提升真实性、提升性能。</p><p><img src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="img"></p><div class="table-container"><table><thead><tr><th>过滤方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_NEAREST_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td>GL_LINEAR_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td>GL_NEAREST_MIPMAP_LINEAR</td><td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td>GL_LINEAR_MIPMAP_LINEAR</td><td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table></div><p>设置方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h1 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h1><p>将图像加载到应用中，需要自己写一个图像加载器，或者使用支持多种格式的图像加载库。</p><h2 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h2><p><a href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_image.h下载链接</a></p><p>将头文件加入你的工程，并在源文件中输入以下代码引入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION <span class="comment">//让头文件只包含相关的函数定义源码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>接下来，我们用stb_image加载图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>加载图片前我们为了防止图片颠倒输出，我们可以输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>); <span class="comment">//OpenGL会自动将图片颠倒，所以我们要上下翻转</span></span><br></pre></td></tr></table></figure><h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><p>创建纹理对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br></pre></td></tr></table></figure><p>生成纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><ul><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数：纹理储存格式。(RGB\RGBA)</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。</li><li>下个参数应该总是被设为<code>0</code>（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为<code>char</code>(byte)数组，我们将会传入对应值。</li><li>最后一个参数：图像数据。</li></ul><p>最后还要释放图像内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure><p><strong>生成纹理的整个过程</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);<span class="comment">//OpenGL会自动将图片颠倒，所以我们要上下翻转</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><p>接下来我们来应用纹理，绘制一个带我的世界草块纹理的矩形：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/grass.jpg">草块图片</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line"><span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// first triangle</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// second triangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在循环中绘制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们的草块就出来了！</p><p>我们再在草块上加上顶点颜色：修改片段着色器</p><p><img src="https://bed.kevinwu.cc/img/grasswin.webp" style="zoom:50%;" /></p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8.cpp">纹理应用源码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord) * <span class="built_in">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://bed.kevinwu.cc/img/colorgrass.webp" style="zoom:50%;" /></p><h1 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h1><p>纹理单元(Texture Unit)：纹理的位置值</p><p>绑定前激活纹理单元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p><strong>我们来做个笑脸草块：</strong></p><p>先修改一下片段着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">    <span class="comment">//mix输出两个texture的混合值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再设置纹理单元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ourShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">//手动设置</span></span><br><span class="line">ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>现在我们绑定多个纹理并绘制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>就可以看到我们的笑脸草块了</p><p><img src="https://bed.kevinwu.cc/img/smilegrass.webp" style="zoom:50%;" /></p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E6%B7%B7%E5%90%88%E7%BA%B9%E7%90%86.cpp">混合纹理源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇将学习OpenGL中关于纹理的各种知识。纹理就是图片，用于给模型添加细节。&lt;/p&gt;
&lt;h1 id=&quot;纹理环绕方式&quot;&gt;&lt;a href=&quot;#纹理环绕方式&quot; class=&quot;headerlink&quot; title=&quot;纹理环绕方式&quot;&gt;&lt;/a&gt;纹理环绕方式&lt;/h1&gt;&lt;p&gt;如果我们把纹理</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="OpenGL" scheme="https://www.kevinwu.cc/articles/tags/OpenGL/"/>
    
    <category term="图形学" scheme="https://www.kevinwu.cc/articles/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL教程 | 2.了解着色器，并绘制彩色三角形</title>
    <link href="https://www.kevinwu.cc/posts/OpenGL2/"/>
    <id>https://www.kevinwu.cc/posts/OpenGL2/</id>
    <published>2023-05-28T08:20:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们会更深入地了解着色器：</p><ol><li>学会着色器如何输入输出</li><li>学会使用Uniform，绘制会随时间变化颜色的图形</li><li>绘制彩色三角形</li><li>定义自己的着色器类</li></ol><p>本文参考<a href="https://learnopengl.com/">LearnOpenGL</a>教学网站</p><blockquote><p>经验：建议打开源代码看着学习，光跟着文档的话思路会很乱</p></blockquote><p>下面是我做的笔记</p><p>配合源码食用更佳🤫：<a href="https://github.com/kevinwu06/LearnOpenGL">OpenGL学习源码</a></p><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p>数据类型：一般使用vecn（包含n个float分量的默认向量）</p><p><strong>重组（灵活的分量选择方式）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重组的例子</span></span><br><span class="line">vec2 someVec;</span><br><span class="line">vec4 differentVec = someVec.xyxx;</span><br><span class="line">vec3 anotherVec = differentVec.zyw;</span><br><span class="line">vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"></span><br><span class="line">vec2 vect = <span class="built_in">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">vec4 result = <span class="built_in">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec4 otherResult = <span class="built_in">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>我们给着色器加上输入和输出，让顶点着色器为片段着色器决定颜色。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行，就可以看到我们成功将颜色由顶点着色器输入到片段着色器中，将三角形的颜色设置成了深红色。</p><p><img src="https://bed.kevinwu.cc/img/redtriangle.png" style="zoom:50%;" /></p><h1 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式</p><p>我们在<strong>片段着色器</strong>中声明Uniform</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以在渲染循环中去改变三角形颜色了。这里我们用让它随时间变化颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p><img src="https://bed.kevinwu.cc/img/uniform.gif" style="zoom:95%;" /></p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/Uniform.cpp">Uniform源码</a></p><h1 id="你好，彩色三角形"><a href="#你好，彩色三角形" class="headerlink" title="你好，彩色三角形"></a>你好，彩色三角形</h1><p>现在，我们将把颜色数据添加为3个值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点数据</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们让顶点着色器接收颜色值，并输出到片段着色器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line">out vec3 ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改一下片段着色器，让他输入颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;  </span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们修改着色器的顶点格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>* <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>然后我们就可以看到一个彩色的三角形😍</p><p><img src="https://bed.kevinwu.cc/img/colorful.webp" style="zoom:50%;" /></p><p>三角形会自动将我们给的三个顶点颜色进行渐变，这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。</p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E5%BD%A9%E8%89%B2%E4%B8%89%E8%A7%92.cpp">彩色三角形源码</a></p><h1 id="自己的着色器类"><a href="#自己的着色器类" class="headerlink" title="自己的着色器类"></a>自己的着色器类</h1><p>管理着色器类是很麻烦的事，所以我们要写一个类来让我们能更轻松的管理。</p><p>我们的着色器类用于：</p><ol><li>打开着色器文件</li><li>编译和链接着色器</li><li>use用来激活着色器程序</li><li>set用于设置和查询uniform</li></ol><p><strong>使用方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;path/to/shaders/shader.vs&quot;</span>, <span class="string">&quot;path/to/shaders/shader.fs&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;someUniform&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">DrawStuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点和片段着色器的文件名可以任意取（推荐用shader.vs和shader.fs，很直观）</p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/shader.h">着色器类源码</a></p><hr><p>恭喜你又学完了一篇教程🎉，你正在向目标一步一步地进发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇我们会更深入地了解着色器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学会着色器如何输入输出&lt;/li&gt;
&lt;li&gt;学会使用Uniform，绘制会随时间变化颜色的图形&lt;/li&gt;
&lt;li&gt;绘制彩色三角形&lt;/li&gt;
&lt;li&gt;定义自己的着色器类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文参考&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="OpenGL" scheme="https://www.kevinwu.cc/articles/tags/OpenGL/"/>
    
    <category term="图形学" scheme="https://www.kevinwu.cc/articles/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL教程 | 1.如何上手OpenGL, 绘制三角形和矩形</title>
    <link href="https://www.kevinwu.cc/posts/OpenGL1/"/>
    <id>https://www.kevinwu.cc/posts/OpenGL1/</id>
    <published>2023-05-24T13:34:08.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于学习OpenGL"><a href="#关于学习OpenGL" class="headerlink" title="关于学习OpenGL"></a>关于学习OpenGL</h1><p>OpenGL是学习计算机图形学的必备，虽然现在Vulkan是未来的OpenGL，但目前OpenGL仍是无法被替代的。</p><p>Vulkan学习难度过高，个人做项目太耗时间，所以OpenGL依旧是很好的选择。很多大神都认为，先学OpenGL打基础，在学习Vulkan的时候再将原先的知识进行分解转化，是个很好的方法。因为学习Vulkan时，想让屏幕上显示点东西需要做的工作太多了，非常容易放弃。(别说Vulkan了，OpenGL就已经够难了🤕)</p><p>所以看了各论坛和思考后，我决定先上手OpenGL。</p><p>这是一个非常好的OpenGL教学网站：<a href="https://learnopengl.com/">英文版</a> | <a href="https://learnopengl-cn.github.io/">中文版</a></p><blockquote><p>经验：建议打开源代码看着学习，光跟着文档的话思路会很乱</p></blockquote><p>下面是我做的笔记</p><p>配合源码食用更佳🤫：<a href="https://github.com/kevinwu06/LearnOpenGL">OpenGL学习源码</a></p><hr><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>因为OpenGL不支持，所以我们需要一个库用于显示窗口和处理用户输入 (如GLUT，SDL，SFML和GLFW)</p><p>这里我们使用GLFW</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>一个专门针对OpenGL的C语言库。<a href="https://www.glfw.org/download.html">GLFW下载</a></p><p>为确保完整性，下载<strong>源代码</strong>后用CMake编译。</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>一个工程文件生成工具。<a href="https://cmake.org/download/">Cmake下载</a></p><h2 id="glad"><a href="#glad" class="headerlink" title="glad"></a>glad</h2><p>用于简化OpenGL获取函数地址的库。<a href="https://glad.dav1d.de/">生成glad</a></p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>在vs项目属性中指向include和lib文件夹</p><p>将glad/src里的glad.c放入工程文件，并在vs中<strong>添加现有项</strong></p><p>在依赖项里加入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfw3.lib;opengl32.lib</span><br></pre></td></tr></table></figure><h1 id="你好，窗口"><a href="#你好，窗口" class="headerlink" title="你好，窗口"></a>你好，窗口</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置项</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化glfw</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建glfw窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="comment">//窗口变换</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//glad加载opengl指针</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理输入</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//渲染</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glfw检查并调用事件，交换缓冲</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw清除</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw，窗口大小变换时自动调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E7%AA%97%E5%8F%A3.cpp">窗口源码</a></p><h1 id="你好，三角形"><a href="#你好，三角形" class="headerlink" title="你好，三角形"></a>你好，三角形</h1><p>现代Opengl渲染至少要设置一个<strong>顶点着色器</strong>和一个<strong>片段着色器</strong>。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ul><li>VAO (顶点数组对象 Vertex Array Object)</li><li>VBO (顶点缓冲对象 Vertex Buffer Object)</li><li>EBO (元素缓冲对象 Element Buffer Object) </li></ul><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>Vertex Shader</p><h4 id="基础源码"><a href="#基础源码" class="headerlink" title="基础源码"></a>基础源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>Fragment Shader 计算像素最后的颜色输出</p><h4 id="基础源码-1"><a href="#基础源码-1" class="headerlink" title="基础源码"></a>基础源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>); <span class="comment">//输出黄色</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>Shader Program Object</p><p>链接多个着色器，将它们合并在一起。</p><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>指定Opengl如何解释顶点数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数：顶点属性。</li><li>第二个参数：顶点属性的大小。顶点属性是一个<strong>vec3</strong>，它由3个值组成，所以大小是3。</li><li>第三个参数：数据的类型，这里是GL_FLOAT(GLSL中<strong>vec*</strong>都是由浮点数值组成的)。</li><li>第四个参数：是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<strong>float</strong>之后，我们把步长设置为<strong>3 * sizeof(float</strong>)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。（译注: <strong>这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节</strong>）。</li><li>最后一个参数：类型是<strong>void*</strong>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="硬编码着色器源码"><a href="#硬编码着色器源码" class="headerlink" title="硬编码着色器源码"></a>硬编码着色器源码</h3><p>定义全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//硬编码着色器源代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="配置着色器"><a href="#配置着色器" class="headerlink" title="配置着色器"></a>配置着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建&amp;编译 着色器</span></span><br><span class="line">   <span class="comment">// ------------------------------------</span></span><br><span class="line">   <span class="comment">// 顶点着色器vertex shader</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">   <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">   <span class="comment">// 检测错误</span></span><br><span class="line">   <span class="type">int</span> success;</span><br><span class="line">   <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">   <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">   <span class="keyword">if</span> (!success)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 片段着色器fragment shader</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">   <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">   <span class="comment">// 检测错误</span></span><br><span class="line">   <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">   <span class="keyword">if</span> (!success)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 着色器程序(链接着色器)</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">   <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">   <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">   <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">   <span class="comment">// 检测错误</span></span><br><span class="line">   <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//删除前面的着色器</span></span><br><span class="line">   <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">   <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 链接顶点属性</span></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">   <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">        <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//VBO顶点缓冲对象，VAO顶点数组对象</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">   <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">   <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">   <span class="comment">// 先绑定VAO，然后VBO，最后设置顶点属性指针</span></span><br><span class="line">   <span class="comment">//bind the Vertex Array Object first, then bindand set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">   <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">   <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解绑</span></span><br><span class="line">   <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>glBufferData参数</strong>:</p><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><h3 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h3><p>在渲染循环中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画三角形</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>然后就可以跟三角形说你好了！😎</p><p><img src="https://bed.kevinwu.cc/img/triangle.webp" style="zoom:50%;" /></p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E4%B8%89%E8%A7%92%E5%BD%A2.cpp">三角形源码</a></p><h1 id="Hey，矩形"><a href="#Hey，矩形" class="headerlink" title="Hey，矩形"></a>Hey，矩形</h1><p>我们绘制两个三角形来组成一个矩形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，我们会看到，有两个顶点是重叠的，这回大大增加开销。所以我们要用到<strong>元素缓冲对象</strong>。</p><h3 id="元素缓冲对象"><a href="#元素缓冲对象" class="headerlink" title="元素缓冲对象"></a>元素缓冲对象</h3><p><strong>EBO</strong> 他存储 OpenGL 用来决定要绘制哪些顶点的索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top right</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom left</span></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top left </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;  <span class="comment">// 从0开始!</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,  <span class="comment">// first Triangle</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   <span class="comment">// second Triangle</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>可以看到现在只用存四个顶点数据</p><p>和VAO,VBO一样，创建并绑到缓冲中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>然后在渲染循环中绘制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>); <span class="comment">//绘制元素缓冲中的内容</span></span><br></pre></td></tr></table></figure><p>然后我们就得到我们的矩形了</p><p><img src="https://bed.kevinwu.cc/img/rectangle.webp" style="zoom:50%;" /></p><p>我们还可以打开线框模式，显示矩形由两个三角形组成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glPolygonMode</span>(GL_FRONT_AND_BACK, GL_LINE)</span><br><span class="line"><span class="comment">//G_LINE打开，GL_FILL关闭</span></span><br></pre></td></tr></table></figure><p><img src="https://bed.kevinwu.cc/img/rectline.webp" style="zoom:50%;" /></p><p>源代码：<a href="https://github.com/kevinwu06/LearnOpenGL/blob/main/%E7%9F%A9%E5%BD%A2.cpp">矩形源码</a></p><hr><p>如果你也到这步了，那么恭喜你🎉，通过了OpenGL最难部分之一。</p><p>接下来的路还很长，我们一起加油。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于学习OpenGL&quot;&gt;&lt;a href=&quot;#关于学习OpenGL&quot; class=&quot;headerlink&quot; title=&quot;关于学习OpenGL&quot;&gt;&lt;/a&gt;关于学习OpenGL&lt;/h1&gt;&lt;p&gt;OpenGL是学习计算机图形学的必备，虽然现在Vulkan是未来的OpenG</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="OpenGL" scheme="https://www.kevinwu.cc/articles/tags/OpenGL/"/>
    
    <category term="图形学" scheme="https://www.kevinwu.cc/articles/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Qt C++】TCP联机小游戏 RectMans</title>
    <link href="https://www.kevinwu.cc/posts/RectMans/"/>
    <id>https://www.kevinwu.cc/posts/RectMans/</id>
    <published>2023-05-11T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>学习TCP后用基于Qt TCP库做了一个联机小游戏🤼</p><p>断断续续大概写了一周，程序源码放在文章底部了。</p><h1 id="结构思路"><a href="#结构思路" class="headerlink" title="结构思路"></a>结构思路</h1><p>游戏通过服务端或者客户端进入，只支持两玩家。</p><p>服务端进入：自己显示红色衣服，对方蓝色</p><p>客户端进入：自己显示蓝色衣服，对方红色</p><p><img src="https://bed.kevinwu.cc/img/rectman.webp" style="zoom:30%;" /></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="位置传输"><a href="#位置传输" class="headerlink" title="位置传输"></a>位置传输</h2><h3 id="发送位置"><a href="#发送位置" class="headerlink" title="发送位置"></a>发送位置</h3><p>将int[]转成QByteArray达到发送多数据的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::sendData</span><span class="params">(<span class="type">int</span> x_self,<span class="type">int</span> y_self,<span class="type">int</span> dir_self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isConnected)&#123;</span><br><span class="line">        <span class="comment">//int[] 转 QByteArray</span></span><br><span class="line">        <span class="type">int</span>  self[<span class="number">3</span>] = &#123;x_self,y_self,dir_self&#125;;</span><br><span class="line">        QByteArray array;</span><br><span class="line">        array.<span class="built_in">append</span>((<span class="type">char</span>*)self, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>);</span><br><span class="line">        socket.<span class="built_in">write</span>(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收位置"><a href="#接收位置" class="headerlink" title="接收位置"></a>接收位置</h3><p>将QByteArray转成int[]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::receiveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// QByteArray 转 int[]</span></span><br><span class="line">    QByteArray array=socket.<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="type">int</span> data[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> unTemp;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;unTemp, array.<span class="built_in">data</span>() + <span class="built_in">sizeof</span>(<span class="type">int</span>) * i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        data[i] = unTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    x=data[<span class="number">0</span>];</span><br><span class="line">    y=data[<span class="number">1</span>];</span><br><span class="line">    dir=data[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相对位置"><a href="#相对位置" class="headerlink" title="相对位置"></a>相对位置</h2><p>自己始终显示在屏幕中间，只显示方向的改变。</p><p>移动时改变坐标但不显示。</p><p>游戏中的物体显示在 <strong>[屏幕中心坐标+物体坐标-自己坐标]</strong></p><p>物体包括：对方玩家，地图，树木</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新函数，放在游戏主循环中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Map::draw</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> <span class="comment">//传入自己坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map-&gt;<span class="built_in">move</span>(CENTER_X+x-a,CENTER_Y+y-b); <span class="comment">//移动到相对位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树木伪3D显示"><a href="#树木伪3D显示" class="headerlink" title="树木伪3D显示"></a>树木伪3D显示</h2><p>很简单，当玩家y坐标大于树时显示在上，小于时显示在下。</p><p>这段代码是有bug的，有两名玩家时，树木上下就会出现问题。</p><p>主要是我没有找到将Label下移或者上移一层的函数，只有置顶和置底，所以代码逻辑很麻烦🤡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tree[i]-&gt;<span class="built_in">getY</span>()&lt;player1-&gt;<span class="built_in">getY</span>()+<span class="number">70</span>&amp;&amp;tree[i]-&gt;<span class="built_in">getY</span>()&gt;player1-&gt;<span class="built_in">getY</span>()<span class="number">-45</span>)</span><br><span class="line">||(tree[i]-&gt;<span class="built_in">getY</span>()&lt;player2-&gt;<span class="built_in">getY</span>()+<span class="number">70</span>&amp;&amp;tree[i]-&gt;<span class="built_in">getY</span>()&gt;player2-&gt;<span class="built_in">getY</span>()<span class="number">-45</span>))&#123;</span><br><span class="line">        tree[i]-&gt;<span class="built_in">Raise</span>();</span><br><span class="line">        <span class="keyword">if</span>(tree[i]-&gt;<span class="built_in">getY</span>()&lt;player1-&gt;<span class="built_in">getY</span>()<span class="number">-45</span>)&#123;</span><br><span class="line">            player1-&gt;<span class="built_in">Raise</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i]-&gt;<span class="built_in">getY</span>()&lt;player2-&gt;<span class="built_in">getY</span>()<span class="number">-45</span>)&#123;</span><br><span class="line">            player2-&gt;<span class="built_in">Raise</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    tree[i]-&gt;<span class="built_in">Lower</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="树木和敌人随机位置生成"><a href="#树木和敌人随机位置生成" class="headerlink" title="树木和敌人随机位置生成"></a>树木和敌人随机位置生成</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;TREE_NUM;i++)&#123;</span><br><span class="line">    <span class="comment">//用QRandomGenerator库，随机生成-1400到1400之间的数字</span></span><br><span class="line">        tree[i]=<span class="keyword">new</span> <span class="built_in">Object</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">-1400</span>,<span class="number">1400</span>),</span><br><span class="line">                           QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">-1400</span>,<span class="number">1400</span>),<span class="number">1</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="僵尸追踪"><a href="#僵尸追踪" class="headerlink" title="僵尸追踪"></a>僵尸追踪</h3><p>僵尸首先会判断与两个玩家间的距离，追踪距离更近的玩家。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enemy::chase</span><span class="params">(Player *p1, Player *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Xp1=p1-&gt;<span class="built_in">getX</span>(),Yp1=p1-&gt;<span class="built_in">getY</span>(),Xp2=p2-&gt;<span class="built_in">getX</span>(),Yp2=p2-&gt;<span class="built_in">getY</span>();</span><br><span class="line">    <span class="type">int</span> disP1=(x-Xp1)*(x-Xp1)+(y-Yp1)*(y-Yp1);</span><br><span class="line">    <span class="type">int</span> disP2=(x-Xp2)*(x-Xp2)+(y-Yp2)*(y-Yp2);</span><br><span class="line">    <span class="keyword">if</span>(disP1&lt;disP2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;Xp1)&#123;</span><br><span class="line">            x+=speed;</span><br><span class="line">            enemy-&gt;<span class="built_in">setPixmap</span>(enemy_r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;Xp1)&#123;</span><br><span class="line">            x-=speed;</span><br><span class="line">            enemy-&gt;<span class="built_in">setPixmap</span>(enemy_l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;Yp1)&#123;</span><br><span class="line">            y+=speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y&gt;Yp1)&#123;</span><br><span class="line">            y-=speed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;Xp2)&#123;</span><br><span class="line">            x+=speed;</span><br><span class="line">            enemy-&gt;<span class="built_in">setPixmap</span>(enemy_r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;Xp2)&#123;</span><br><span class="line">            x-=speed;</span><br><span class="line">            enemy-&gt;<span class="built_in">setPixmap</span>(enemy_l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;Yp2)&#123;</span><br><span class="line">            y+=speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y&gt;Yp2)&#123;</span><br><span class="line">            y-=speed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h1><iframe src="//player.bilibili.com/player.html?aid=443100831&bvid=BV1oL411h7Ms&cid=1112953964&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码：<a href="https://github.com/kevinwu06/RectMans">https://github.com/kevinwu06/RectMans</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习TCP后用基于Qt TCP库做了一个联机小游戏🤼&lt;/p&gt;
&lt;p&gt;断断续续大概写了一周，程序源码放在文章底部了。&lt;/p&gt;
&lt;h1 id=&quot;结构思路&quot;&gt;&lt;a href=&quot;#结构思路&quot; class=&quot;headerlink&quot; title=&quot;结构思路&quot;&gt;&lt;/a&gt;结构思路&lt;/h1</summary>
      
    
    
    
    <category term="我的项目" scheme="https://www.kevinwu.cc/articles/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="游戏" scheme="https://www.kevinwu.cc/articles/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="Qt" scheme="https://www.kevinwu.cc/articles/tags/Qt/"/>
    
    <category term="TCP" scheme="https://www.kevinwu.cc/articles/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>【Qt C++】TCP聊天程序DuckChat</title>
    <link href="https://www.kevinwu.cc/posts/DuckChat/"/>
    <id>https://www.kevinwu.cc/posts/DuckChat/</id>
    <published>2023-04-24T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>用Qt和C++开发了一个基于TCP协议的通信程序，源码放在文章底部了。</p><p>TCP是一种传输协议，以服务器和客户端的形式运行。</p><p>Qt中提供了QTcpServer类来编写服务器端程序，以及QTcpSocket类来编写客户端程序。</p><p>服务端开启对一个端口的监听，等待客户端连入。</p><p><img src="https://bed.kevinwu.cc/img/duckchat.webp" style="zoom:30%;" /></p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>服务端继承于QTcpServer类，加上Q_OBJECT</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> : <span class="keyword">public</span> QTcpServer</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line">Server::<span class="built_in">Server</span>(QObject *parent)</span><br><span class="line">    : QTcpServer&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询ip和端口"><a href="#查询ip和端口" class="headerlink" title="查询ip和端口"></a>查询ip和端口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano 活动连接列表</span><br><span class="line"></span><br><span class="line">ipconfig /all 查看ip</span><br></pre></td></tr></table></figure><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>服务端用QTcpServer监听端口，用QTcpSocket 读取和写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;<span class="built_in">listen</span>(QHostAddress::Any,<span class="number">8888</span>); <span class="comment">//开始监听端口</span></span><br></pre></td></tr></table></figure><h2 id="连入"><a href="#连入" class="headerlink" title="连入"></a>连入</h2><p>连接后自动触发的函数，开始接受数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::incomingConnection</span><span class="params">(qintptr handle)</span></span>&#123;</span><br><span class="line">    socket.<span class="built_in">setSocketDescriptor</span>(handle);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;socket,<span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">receiveData</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::receiveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray message=socket.<span class="built_in">readAll</span>();</span><br><span class="line">    str=message.<span class="built_in">data</span>(); <span class="comment">//转为QString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::sendData</span><span class="params">(QString text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    socket.<span class="built_in">write</span>(text.<span class="built_in">toUtf8</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>用QTcpSocket实现连接及收发</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTcpSocket* socket;</span><br><span class="line">socket.<span class="built_in">connectToHost</span>(IP,PORT); <span class="comment">//连接</span></span><br><span class="line"><span class="keyword">if</span>(socket.<span class="built_in">waitForConnected</span>(<span class="number">1000</span>))&#123;  <span class="comment">//等待1秒连接</span></span><br><span class="line">        <span class="built_in">qDebug</span>(<span class="string">&quot;成功连接聊天室...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>(<span class="string">&quot;连接失败...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">connect</span>(&amp;socket,<span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">receiveData</span>()));</span><br></pre></td></tr></table></figure><h2 id="接受和发送"><a href="#接受和发送" class="headerlink" title="接受和发送"></a>接受和发送</h2><p>接受和发送与服务端相同</p><h1 id="界面UI"><a href="#界面UI" class="headerlink" title="界面UI"></a>界面UI</h1><p>QSS是QT受CSS启发做的样式表语言，在简单的qt程序制作中非常好用。</p><h2 id="界面背景"><a href="#界面背景" class="headerlink" title="界面背景"></a>界面背景</h2><p>在坐标(0,0)处放QLabel并拉满整个窗口，样式表中放入照片，照片要先导入到qrc资源文件中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/Images/duckl.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按钮样式表"><a href="#按钮样式表" class="headerlink" title="按钮样式表"></a>按钮样式表</h2><p>hover是鼠标放在上面显示的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> QPushButton &#123;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">0.5px</span> solid white;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">     <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">90</span>,<span class="number">194</span>,<span class="number">198</span>);</span><br><span class="line">     <span class="attribute">min-width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">11pt</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line"> &#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123; </span><br><span class="line"><span class="attribute">border</span>: <span class="number">0.5px</span> solid white;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">     <span class="attribute">background-color</span>: <span class="number">#1fab89</span>;</span><br><span class="line">     <span class="attribute">min-width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">10pt</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局样式表"><a href="#全局样式表" class="headerlink" title="全局样式表"></a>全局样式表</h2><p>编辑基类widget样式表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QWidget&#123;</span><br><span class="line"><span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">QLineEdit &#123;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">0.5px</span> solid <span class="built_in">rgb</span>(<span class="number">147</span>, <span class="number">150</span>, <span class="number">154</span>);</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">40</span>, <span class="number">44</span>, <span class="number">52</span>,<span class="number">150</span>);</span><br><span class="line">      <span class="attribute">min-width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">11pt</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">147</span>, <span class="number">150</span>, <span class="number">154</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h1><p>源码：<a href="https://github.com/kevinwu06/DuckChat">https://github.com/kevinwu06/DuckChat</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用Qt和C++开发了一个基于TCP协议的通信程序，源码放在文章底部了。&lt;/p&gt;
&lt;p&gt;TCP是一种传输协议，以服务器和客户端的形式运行。&lt;/p&gt;
&lt;p&gt;Qt中提供了QTcpServer类来编写服务器端程序，以及QTcpSocket类来编写客户端程序。&lt;/p&gt;
&lt;p&gt;服务端开</summary>
      
    
    
    
    <category term="我的项目" scheme="https://www.kevinwu.cc/articles/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="Qt" scheme="https://www.kevinwu.cc/articles/tags/Qt/"/>
    
    <category term="TCP" scheme="https://www.kevinwu.cc/articles/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>【Qt C++】Fighter Duck</title>
    <link href="https://www.kevinwu.cc/posts/FighterDuck/"/>
    <id>https://www.kevinwu.cc/posts/FighterDuck/</id>
    <published>2023-04-14T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Qt，做了个游戏当练手项目。</p><p>断断续续大概写了两周，程序源码放在文章底部了。</p><h1 id="游戏美术"><a href="#游戏美术" class="headerlink" title="游戏美术"></a>游戏美术</h1><p>用软件Aseprite自己绘制。Aseprite是一款专门针对像素画的软件，界面简洁，适合快速上手，没有ps那些繁琐的功能。</p><p>游戏动态背景用ps做成，因为ps的动画功能可以实现流畅的帧变换。</p><p><img src="https://bed.kevinwu.cc/img/drawduck.webp" style="zoom: 25%;" /></p><h1 id="游戏代码"><a href="#游戏代码" class="headerlink" title="游戏代码"></a>游戏代码</h1><p>接下来是如何用Qt提供的接口来实现一些游戏的基本功能</p><p><img src="https://bed.kevinwu.cc/img/duckgame.webp" style="zoom: 50%;" /></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>游戏人物的动态用的是gif动图</p><p>用QLabel和QMovie实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QLabel *duck=<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">QMovie *duck_stand=<span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;Images/duck_stand.gif&quot;</span>);</span><br><span class="line">duck-&gt;<span class="built_in">setMovie</span>(duck_stand);</span><br><span class="line">duck_stand-&gt;<span class="built_in">start</span>(); <span class="comment">//开始播放</span></span><br><span class="line">duck-&gt;<span class="built_in">setFixedSize</span>(<span class="number">150</span>,<span class="number">150</span>); <span class="comment">//设置大小</span></span><br><span class="line">   duck-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>); <span class="comment">//自动大小匹配</span></span><br><span class="line">duck-&gt;<span class="built_in">move</span>(x,y); <span class="comment">//移动位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>显示静态图片用QLabel和QPixmap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *duck=<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">QPixmap duck_stand;</span><br><span class="line">duck_stand.<span class="built_in">load</span>(<span class="string">&quot;Images/duck_stand.gif&quot;</span>);</span><br><span class="line">QLabel-&gt;<span class="built_in">setMovie</span>(duck_stand);</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>在head文件中加入，再在源文件中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent* e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent* e)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="游戏主循环"><a href="#游戏主循环" class="headerlink" title="游戏主循环"></a>游戏主循环</h2><p>控制帧率，一秒循环多少次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer=<span class="keyword">new</span> QTimer;</span><br><span class="line"><span class="built_in">connect</span>(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;GameEngine::MainGame); <span class="comment">//MainGame()是循环的函数</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>/FRAME); <span class="comment">//FRAME帧率</span></span><br></pre></td></tr></table></figure><h2 id="Delay函数"><a href="#Delay函数" class="headerlink" title="Delay函数"></a>Delay函数</h2><p>Qt中要使用delay函数可以自己定义，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delay</span><span class="params">(<span class="type">int</span> msec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTime dieTime= QTime::<span class="built_in">currentTime</span>().<span class="built_in">addMSecs</span>(msec);</span><br><span class="line">    <span class="keyword">while</span>( QTime::<span class="built_in">currentTime</span>() &lt; dieTime )</span><br><span class="line">    QCoreApplication::<span class="built_in">processEvents</span>(QEventLoop::AllEvents, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示文字"><a href="#显示文字" class="headerlink" title="显示文字"></a>显示文字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *health=<span class="keyword">new</span> <span class="built_in">QLabel</span>(widget);</span><br><span class="line">string_health_number= QString::<span class="built_in">number</span>(health_number, <span class="number">10</span>); <span class="comment">//将int类型转化成QString</span></span><br><span class="line">health-&gt;<span class="built_in">setText</span>(string_health_number);</span><br><span class="line">health-&gt;<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;Microsoft YaHei&quot;</span>, <span class="number">20</span>, QFont::Bold));</span><br><span class="line">health-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color:red;&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://bed.kevinwu.cc/img/fighterduck.webp" style="zoom: 30%;" /></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码：<a href="https://github.com/kevinwu06/FighterDuck">https://github.com/kevinwu06/FighterDuck</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习Qt，做了个游戏当练手项目。&lt;/p&gt;
&lt;p&gt;断断续续大概写了两周，程序源码放在文章底部了。&lt;/p&gt;
&lt;h1 id=&quot;游戏美术&quot;&gt;&lt;a href=&quot;#游戏美术&quot; class=&quot;headerlink&quot; title=&quot;游戏美术&quot;&gt;&lt;/a&gt;游戏美术&lt;/h1&gt;&lt;p&gt;用软件A</summary>
      
    
    
    
    <category term="我的项目" scheme="https://www.kevinwu.cc/articles/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="游戏" scheme="https://www.kevinwu.cc/articles/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="Qt" scheme="https://www.kevinwu.cc/articles/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出程序设计竞赛》基础笔记</title>
    <link href="https://www.kevinwu.cc/posts/DeepFoundation/"/>
    <id>https://www.kevinwu.cc/posts/DeepFoundation/</id>
    <published>2023-03-30T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>《深入浅出程序设计竞赛》是洛谷站长出的书，帮助青少年上手C++算法竞赛。书中对学习算法竞赛的顺序编排非常好，很系统，很适合用于算法竞赛入门。文章最后有书籍pdf版。</p><hr><p><strong>下面是我从基础语言入门部分(第一部分)总结出来的精华笔记。</strong></p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>在文件里创建 title.in文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freeopen</span>(<span class="string">&quot;title.in&quot;</span>,<span class="string">&quot;w&quot;</span>,stdin);</span><br><span class="line"></span><br><span class="line"><span class="built_in">freeopen</span>(<span class="string">&quot;title.out&quot;</span>,<span class="string">&quot;r&quot;</span>,stdout);</span><br></pre></td></tr></table></figure><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h4 id="cstdio头文件"><a href="#cstdio头文件" class="headerlink" title="cstdio头文件"></a>cstdio头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">printf</span>(%d,a);</span><br></pre></td></tr></table></figure><h4 id="cmath头文件"><a href="#cmath头文件" class="headerlink" title="cmath头文件:"></a>cmath头文件:</h4><p>包含一系列<strong>数学函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根号sqrt, 几次方pow</span><br></pre></td></tr></table></figure><h4 id="algorithm头文件："><a href="#algorithm头文件：" class="headerlink" title="algorithm头文件："></a>algorithm头文件：</h4><p>一系列<strong>算法函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min, max, sort, swap</span><br></pre></td></tr></table></figure><h4 id="cstring头文件："><a href="#cstring头文件：" class="headerlink" title="cstring头文件："></a>cstring头文件：</h4><p>用于char字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlen获取字符串长度，strcpy复制字符串内容</span><br><span class="line">fgets读入字符串，sscanf获取字符串，sprintf输</span><br></pre></td></tr></table></figure><h1 id="杂货"><a href="#杂货" class="headerlink" title="杂货"></a>杂货</h1><h4 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码:"></a>ASCII码:</h4><p>‘A’=66, ‘a’=97</p><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换:"></a>强制转换:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)a</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span>(<span class="type">int</span> a) <span class="comment">//在这个函数里面对放入的a进行修改，函数外是不会生效的。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">stat</span>(<span class="type">int</span> &amp;a) <span class="comment">//相当于给放入的变量取了个别名，对其修改，该变量也会改变。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">stat</span>(<span class="type">int</span> a[]) <span class="comment">//相当于传入&amp;a[]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) <span class="comment">//这也是一样，相当于把n的地址告诉函数，这样才能输入到n中。</span></span><br></pre></td></tr></table></figure><h4 id="左移-右移运算符"><a href="#左移-右移运算符" class="headerlink" title="左移/右移运算符"></a>左移/右移运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移运算符</span></span><br><span class="line">i&lt;&lt;n = i*<span class="number">2</span>^n^</span><br><span class="line"><span class="comment">//右移运算符</span></span><br><span class="line">i&gt;&gt;n=i/<span class="number">2</span>^n^</span><br></pre></td></tr></table></figure><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>))</span><br><span class="line">ans=<span class="built_in">rand</span>()%a<span class="comment">//生成0到(a-1)随机数</span></span><br><span class="line"><span class="comment">//ans=rand()%(b-a+1)+a生成a到b随机数</span></span><br></pre></td></tr></table></figure><h4 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符: ^"></a>异或运算符: ^</h4><p>一个成立一个不成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>^<span class="literal">false</span>=<span class="literal">true</span></span><br><span class="line"><span class="literal">true</span>^<span class="literal">true</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h4 id="char字符串"><a href="#char字符串" class="headerlink" title="char字符串"></a>char字符串</h4><p>结束标记字符：’\0’</p><p><strong>读入字符串方法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;s;</span><br></pre></td></tr></table></figure><p>这两种方法只能读到空格或者换行就会终止</p><p>如果要输入<strong>包括空格或换行的字符串</strong>，并存入一个字符串中，就用下面这种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">s = <span class="built_in">getchar</span>();<span class="comment">//读入字符</span></span><br><span class="line"><span class="keyword">if</span> (s == EOF) <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line"><span class="built_in">putchar</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束输入的时候，要使用组合键Ctrl+Z，然后回车。</p><p>这是因为getchar返回EOF(End of file)代表文件读入完毕。</p><p>windows下输入Ctrl+z / Linux下输入Ctrl+D 来输入EOF标记</p><h4 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h4><p>加强版字符串，可以赋值、拼接</p><p><strong>字符串string需要使用头文件 string,包括下面的常用方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义字符串变量s</span></span><br><span class="line">string s;</span><br><span class="line"><span class="comment">//拼接字符串1</span></span><br><span class="line">s+=str;</span><br><span class="line"><span class="comment">//拼接字符串2</span></span><br><span class="line">s.<span class="built_in">append</span>(str);</span><br><span class="line"><span class="comment">//比较字符串 s 的字典序是否在字符 str 的字典序之前</span></span><br><span class="line">s&lt;str;</span><br><span class="line"><span class="comment">//获取长度1</span></span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//获取长度2</span></span><br><span class="line">s.<span class="built_in">length</span>( );</span><br><span class="line"><span class="comment">//截取字符串s,从第 pos 个位置开始len 个字符</span></span><br><span class="line">s.<span class="built_in">substr</span>(pos,len);</span><br><span class="line"><span class="comment">//在字符串s的第 pos 个字符之前插字符串 st</span></span><br><span class="line">s.<span class="built_in">insert</span>(pos,str);</span><br><span class="line"><span class="comment">//在字符串 s 中从第 pos 个字符开始寻找 str,并返回位置,如果找不到返回-1。pos 可以省略,默认值是 0。</span></span><br><span class="line">s.<span class="built_in">find</span>(str,[pos]);</span><br><span class="line"><span class="comment">//可以获取带空格字符串</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure><p><a href="https://kevinwu06.lanzout.com/igPpV0rpkuve">深入浅出程序设计竞赛.zip 蓝奏云</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;《深入浅出程序设计竞赛》是洛谷站长出的书，帮助青少年上手C++算法竞赛。书中对学习算法竞赛的顺序编排非常好，很系统，很适合用于算法竞赛入门。</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书" scheme="https://www.kevinwu.cc/articles/tags/%E4%B9%A6/"/>
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何学精排序算法？</title>
    <link href="https://www.kevinwu.cc/posts/Sort/"/>
    <id>https://www.kevinwu.cc/posts/Sort/</id>
    <published>2023-02-27T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="各种排序"><a href="#各种排序" class="headerlink" title="各种排序"></a>各种排序</h3><div class="table-container"><table><thead><tr><th>排序</th><th>概述</th><th>时间复杂度</th></tr></thead><tbody><tr><td>计数排序</td><td>对应票投入对应票箱</td><td>O(n)</td></tr><tr><td>选择排序</td><td>最小的放前 (两重循环)</td><td>O(n^2^)</td></tr><tr><td>冒泡排序</td><td>依次比较相邻 (两重循环)</td><td>O(n^2^)</td></tr><tr><td>插入排序</td><td>依次拿出一张牌插入排列中 (两重循环)</td><td>O(n^2^)</td></tr><tr><td>…</td><td></td></tr></tbody></table></div><p>这些排序各适用不同情况，但时间复杂度总体较大。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>程序设计竞赛中最普遍的排序。</p><p>随机选择哨兵，时间复杂度O(n log n)。但极端情况O(n^2^)。</p><p><strong>概述：</strong> </p><p>选出一个哨兵，比哨兵小的数全放左边，比他大的全放右边。</p><p>再分别在左边和右边选出哨兵，进行分类。</p><p>以此循环，直到排序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> num[],<span class="type">int</span> first,<span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = first, j = last, flag = num[(first + last) / <span class="number">2</span>], temp;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (num[i] &lt; flag) i++;</span><br><span class="line"><span class="keyword">while</span> (num[j] &gt; flag) j--;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= j) &#123; </span><br><span class="line">temp = num[i];</span><br><span class="line">num[i] = num[j];</span><br><span class="line">num[j] = temp;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= j); <span class="comment">//带=为了让i和j交错而过，这样才可以用递归</span></span><br><span class="line"><span class="keyword">if</span>(first&lt;j) <span class="built_in">qsort</span>(num, first, j);</span><br><span class="line"><span class="keyword">if</span>(i&lt;last) <span class="built_in">qsort</span>(num, i, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, num[<span class="number">100000</span>];</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//必须从i=1开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cout &lt;&lt; num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以直接用algorithm头文件中的sort函数，</p><p>我们学会自己写是为了理解原理，提升思维，</p><p>同时在有特殊需求的时候可以更自定义化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;各种排序&quot;&gt;&lt;a href=&quot;#各种排序&quot; class=&quot;headerlink&quot; title=&quot;各种排序&quot;&gt;&lt;/a&gt;各种排序&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;排序&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://www.kevinwu.cc/articles/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Computational Fairy Tales Notes</title>
    <link href="https://www.kevinwu.cc/posts/FairyTales/"/>
    <id>https://www.kevinwu.cc/posts/FairyTales/</id>
    <published>2023-02-26T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This is a book on the <strong>Computer Science book list of Oxford</strong>. It is a good book for crossing the threshold of computer science. </p><p>The book briefly introduces the some <strong>fundamental knowledges</strong> of computer science through an interesting adventure story.</p><p>I recognized many <strong>computational terms</strong> in the book that I’ve already learned in Chinese. So it helped me to know the spelling of the computational terms in English. And I also learned a lot that I’ve not learned about. I’ll keep on studying computer science and be on the way for fulfilling my dream.</p><p>I note down all the essential terms in the book to sum it up and help me for review.</p><h1 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h1><p><strong>Computer Science:</strong> a way of thinking about problems.</p><p>A set of core concepts-approaches to solving fundamental problems,and how combine them to solve larger and more complex problem.</p><p><strong>Algorithm: </strong>a set of specific steps for solving a problem.</p><p><strong>Variable: </strong>a place in memory where you can store a single piece of data.</p><p><strong>IF-ELSE statements:</strong> branch off and execute one of different blocks of code.</p><p><strong>Loops: </strong>programming constructs for repeating a set of instructions until some terminal criterion is met.</p><p><strong>Boolean logic: </strong>base on two values: TRUE and FALSE</p><p><strong>Binary:</strong> a number system which each digit can take one of 0 or 1.</p><p>101=(1x2^2^)(0x2^1^)(1x2^0^)</p><p><strong>Pseudocode: </strong>an informal understandable way of writing algorithms.</p><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p><strong>Arrays:</strong> like a set of bins with a fixed number of slots.</p><p><strong>Strings:</strong> sequences(array) of characters</p><p><strong>Swapping two values:</strong> </p><p>1.put one into temporary storage </p><p>2.the other in the memory location of first entry </p><p>3.the data from temporary storage is written to second entry.</p><p><strong>Pointers:</strong> variables that hold addresses in the computer memory. <em>Flexible</em></p><p><strong>Linked lists:</strong> data structures that store lists of items. Use pointer to store the next and previous node.</p><p><strong>Stacks:</strong> last-in, first-out data structure.</p><p><strong>Queues:</strong> first in, first out data structure.</p><p><strong>Priority queues:</strong> return the highest priority data.</p><p><strong>Binary search trees:</strong>  efficient searches by value like a tree.</p><p><strong>Caching data:</strong> storing a copy of data in a quickly accessible location to speed up future accesses of that data.</p><p><strong>Recursion:</strong> a problem-solving technique that  builds a solution to a problem from solutions to smaller subproblems of the same type.</p><p><strong>Binary search:</strong> algorithm for efficiently finding a target value within a sorted list.</p><p><strong>Insertion sort:</strong> simple inefficient sorting an array of number.</p><p><strong>Bubble sort:</strong> Swapping adjacent elements if they are out of order.</p><p><strong>Merge sort:</strong> Break the data in half, sort each half separately using merge sort and merge together.</p><p><strong>*Oracle’s Array:</strong> Using algorithms and data structures together to create complex programs.</p><p><strong>Graph:</strong> is defined by a set of nodes and a set of edges that link together the nodes.</p><p>Directed/Undirected</p><p>Weighted/Unweighted</p><p><strong>Dijkstra’s algorithm:</strong> find the shortest path from a given starting node to all other nodes in the graph.</p><p><strong>Representations of graphs:</strong> two common data structure representing graphs: </p><p>​        <strong>adjacency matrix:</strong> One row and one column for each node.</p><p>​        <strong>adjacency list:</strong> a separate list of neighbors for each node.</p><p><strong>Traveling  salesman problem:</strong> find the shortest path through a graph that visits each node and return to the starting node. <strong><em>NP-hard</em></strong></p><p><strong>Depth-first search:</strong> a search algorithm that fully explores a single path before backtracking to test other paths.</p><p><strong>Minimum Spanning Tree:</strong>  the smallest set of edges that all of the nodes are connected.</p><p><strong>Hamiltonian path:</strong> visits each node in a graph exactly one time. <strong><em>NP-Hard</em></strong></p><h1 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h1><p>Complex algorithms build on a core set of fundamental concepts. Mastering them and learn to combine them is the key to solving to problems.</p><p><strong>NP-Hard:</strong> computational problems for which there are no known efficient and exact solution.</p><p><strong>Quicksort:</strong> a recursive sorting algorithm that is similar to merge sort but faster.</p><p><strong>Comments:</strong> additional text within code that improve the read ability.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;This is a book on the &lt;strong&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书" scheme="https://www.kevinwu.cc/articles/tags/%E4%B9%A6/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何用SDL开发游戏？</title>
    <link href="https://www.kevinwu.cc/posts/SDLgame/"/>
    <id>https://www.kevinwu.cc/posts/SDLgame/</id>
    <published>2023-01-24T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>SDL（Simple DirectMedia Layer）是一套开放源代码的<strong>跨平台多媒体开发库</strong>，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台的应用软件。现SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。</p><p>最近前段时间浅学习了下SDL，以及做游戏。这篇文章总结下。</p><h1 id="游戏结构"><a href="#游戏结构" class="headerlink" title="游戏结构"></a>游戏结构</h1><p>做游戏这里最主要的是<strong>面向对象</strong>编程思想。</p><p><strong>多创建类文件</strong>可以帮助我们更好的理清逻辑，管理代码。</p><p>整个游戏的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Init</span>();<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span>(Running)<span class="comment">//运行状态循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Events</span>();<span class="comment">//事件</span></span><br><span class="line"><span class="built_in">Loop</span>();<span class="comment">//循环</span></span><br><span class="line"><span class="built_in">Render</span>();<span class="comment">//渲染</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Clean</span>();<span class="comment">//清除</span></span><br></pre></td></tr></table></figure><p>这样把整个游戏结构写成函数形式可以让我们更好的管理代码。这应该就是我们main函数大概的样子。</p><h1 id="SDL函数"><a href="#SDL函数" class="headerlink" title="SDL函数"></a>SDL函数</h1><p>接下来我们来看看SDL给我们提供的函数，让我们怎么去实现游戏功能。</p><p>首先我们来看看一个简单的SDL<strong>创建窗口</strong>的程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>**)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_VIDEO)) &#123;</span><br><span class="line"><span class="built_in">SDL_Log</span>(<span class="string">&quot;Cannot Init Video,%s&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SDL_Window* win = <span class="built_in">SDL_CreateWindow</span>(</span><br><span class="line"><span class="string">&quot;Title&quot;</span>,</span><br><span class="line">SDL_WINDOWPOS_CENTERED,</span><br><span class="line">SDL_WINDOWPOS_CENTERED,</span><br><span class="line"><span class="number">400</span>, <span class="number">300</span>, SDL_WINDOW_SHOWN</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (win == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">SDL_Log</span>(<span class="string">&quot;Cannot Create Window,%s&quot;</span>,<span class="built_in">SDL_GetError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SDL_Delay</span>(<span class="number">3000</span>); <span class="comment">//延迟3000毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SDL_DestroyWindow</span>(win);</span><br><span class="line"><span class="built_in">SDL_Quit</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h2><p>我们可以看到我们在初始化和创建的时候<strong>会写一个判断语句</strong>。</p><p>这是为什么？</p><p>因为有时可能会因为各种原因导致<strong>初始化失败</strong>或者<strong>创建失败</strong>，到后面代码多了如果某个环节失败了，我们想要找出问题所在会非常困难。</p><p>所以我们在初始化和创建的时候写判断语句，比如第一个<strong>SDL_Init()</strong>，这个SDL给出的函数如果失败了会返回1(可以右键进入定义代码查看)，所以如果返回了1，我们就用<strong>SDL_Log()</strong>函数(SDL给出的输出函数,也可以用cout或者printf)输出问题，后面的<strong>SDL_Error()</strong>可以获取问题。</p><p>这样的检测故障的判断是必须的。</p><h2 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h2><p>可以看到我们最后使用了</p><pre><code>SDL_DestroyWindow(win);SDL_Quit();</code></pre><p>这是官方给出的销毁/清除的函数。</p><p>在我们初始化了SDL的功能后，在程序末尾我们必须用SDL_Quit()将其清除。</p><p>同样道理，我们用SDL创建的数据变量也应该销毁/释放掉。</p><p>(每个数据变量都有对应的销毁/释放函数，如SDL_DestroyRenderer,SDL_FreeSurface)</p><h1 id="SDL学习"><a href="#SDL学习" class="headerlink" title="SDL学习"></a>SDL学习</h1><p>SDL给出了非常非常多的功能函数。</p><p>大家使用时应该学会查看官方文档，里面都给出了详细的使用方法。</p><p>这是我之前学习SDL的文件，里面有一些最基本功能的实现，大家可以看看。</p><p><a href="https://kevinwu06.lanzout.com/i3Stw0lrzw4f">SDL学习文件 蓝奏云</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SDL（Simple DirectMedia Layer）是一套开放源代码的&lt;strong&gt;跨平台多媒体开发库&lt;/strong&gt;，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台的应用软件。现SDL多用于开</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="游戏" scheme="https://www.kevinwu.cc/articles/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="SDL2" scheme="https://www.kevinwu.cc/articles/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>如何学精链表？</title>
    <link href="https://www.kevinwu.cc/posts/LinkList/"/>
    <id>https://www.kevinwu.cc/posts/LinkList/</id>
    <published>2023-01-08T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>我们存储很多数的时候，通常使用数组，但是数组不够灵活。</p><p>哦？为什么说不灵活？</p><p>我们如果要在一个数组前面或者中间插入一个数，就会很麻烦。</p><p>假设我们有一个数组a,里面是排序好的数字,我们要将7按大小顺序插入数组</p><p>我们就得把后面的数全都依次往后移一位，再将7放入。</p><p><img src="https://bed.kevinwu.cc/img/linklist1.webp" style="zoom:50%;" /></p><p>这样如果后面的数非常多的话就会很耽误时间。</p><p>所以我们需要用到<strong>链表</strong>。</p><p>链表就是利用<strong>结构体</strong>和<strong>指针</strong>，在存储数据的同时，存储一个指向下一个结点的指针。</p><p>这样我们要插入数字的时候，只要修改下指针的指向，就可以快速的进行插入或取出之类的操作。</p><p><img src="https://bed.kevinwu.cc/img/linklist2.webp" style="zoom:50%;" /></p><p>链表有很多种：</p><p><strong>单链表:</strong>每个结点记录后继(图片演示的就是)</p><p><strong>双链表:</strong>每个结点记录前驱和后继，它比单链多了个往前走的功能</p><p><strong>循环单链表:</strong>将单链表的最后一个结点的后继指向第一个结点，形成一个环形结构</p><p><strong>循环双链表:</strong>将双链表连成环形</p><p>…（还有几种就不一一列述了）</p><p>这里我们设计一个程序实现一下链表，首先输入四个按大小顺序排列的数字，然后再输入要插入的数字，</p><p>程序会输出插入后的排列</p><p>先上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//存数据</span></span><br><span class="line">node* next;<span class="comment">//后继指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">node* head, * p, * q = <span class="literal">NULL</span>;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//用指针p指向一个动态申请的node大小的空间</span></span><br><span class="line">p = (node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="comment">//将数据存入当前结点(p指向的结点)</span></span><br><span class="line">p-&gt;data = a;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)head = p;<span class="comment">//如果是第一个结点，就将头指针指向当前结点</span></span><br><span class="line"><span class="keyword">else</span> q-&gt;next = p;<span class="comment">//否则将上一个结点的后继指针指向当前结点</span></span><br><span class="line">q = p;<span class="comment">//将q指向当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">node* t = head;<span class="comment">//从链表头开始遍历</span></span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;next-&gt;data &gt; b) &#123;</span><br><span class="line">p = (node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line"><span class="comment">//将数据存入当前结点(p指向的结点)</span></span><br><span class="line">p-&gt;data = b;</span><br><span class="line">p-&gt;next = t-&gt;next;<span class="comment">//将当前结点的后继指针指向下一结点</span></span><br><span class="line">t-&gt;next = p;<span class="comment">//将上一结点的后继指针指向当前结点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">t = t-&gt;next;<span class="comment">//下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">t = head;<span class="comment">//从链表头开始遍历</span></span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; endl;</span><br><span class="line">t = t-&gt;next;<span class="comment">//下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放动态申请的空间(确保安全)</span></span><br><span class="line">t = head;</span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">node* current = t;<span class="comment">//记录当前结点</span></span><br><span class="line">t = t-&gt;next;<span class="comment">//下一结点</span></span><br><span class="line"><span class="built_in">free</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不长，但是可能需要时间理解。</p><p>讲讲<strong>malloc函数</strong>，malloc函数的作用是<strong>动态分配内存</strong>。</p><p>每次输入数据前，我们就用p指向一个动态申请的新空间，然后存入数据。</p><p>程序的最后，我们用<strong>free()函数</strong>来<strong>释放</strong>动态申请的<strong>空间</strong>，这样可以让我们的程序更安全。</p><p>我们学习c语言和c++应该追求最大程度地优化，排除可能出现的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们存储很多数的时候，通常使用数组，但是数组不够灵活。&lt;/p&gt;
&lt;p&gt;哦？为什么说不灵活？&lt;/p&gt;
&lt;p&gt;我们如果要在一个数组前面或者中间插入一个数，就会很麻烦。&lt;/p&gt;
&lt;p&gt;假设我们有一个数组a,里面是排序好的数字,我们要将7按大小顺序插入数组&lt;/p&gt;
&lt;p&gt;我们就得把</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://www.kevinwu.cc/articles/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何高效地筛出质数？(欧拉筛)</title>
    <link href="https://www.kevinwu.cc/posts/SievePrime/"/>
    <id>https://www.kevinwu.cc/posts/SievePrime/</id>
    <published>2022-12-23T03:29:22.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>如何高效筛素数？让我们来看看</p><p><strong>题目：</strong>生成一个1到n范围内的质数数组</p><h1 id="菜鸟这样做（枚举法）"><a href="#菜鸟这样做（枚举法）" class="headerlink" title="菜鸟这样做（枚举法）"></a>菜鸟这样做（枚举法）</h1><p>从1枚举到n，判断是素数就存入数组</p><p>下面是判断方法</p><h2 id="菜鸟："><a href="#菜鸟：" class="headerlink" title="菜鸟："></a>菜鸟：</h2><p>从2枚举到n-1，如果有能整除该数的，该数就是质数。</p><h2 id="进化版菜鸟："><a href="#进化版菜鸟：" class="headerlink" title="进化版菜鸟："></a>进化版菜鸟：</h2><p>菜鸟进化了，从2枚举到$\sqrt n$</p><hr><h1 id="高手版"><a href="#高手版" class="headerlink" title="高手版"></a>高手版</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>这样筛掉后每次下一位没被筛掉的数就都是质数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> numlist[<span class="number">100000</span>];</span><br><span class="line"><span class="comment">//0代表质数，1代表非质数</span></span><br><span class="line"><span class="type">int</span> prime[<span class="number">100000</span>], count;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(numlist[i]==<span class="number">0</span>)&#123;  <span class="comment">//如果是质数</span></span><br><span class="line">prime[++count] = i ;  <span class="comment">//就先存入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; i*j&lt;=n; j++) numlist[i*j] = <span class="number">1</span>;  <span class="comment">//然后将其平方后的所有倍数筛掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这钟筛法还不是最优，因为p的倍数会重复，所以有些数会被重复筛掉。</p><p>那么就引出了我们的最终筛法。</p><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p><img src="https://bed.kevinwu.cc/img/欧拉.webp"></p><p>这个筛法避免了重复筛，思路就是：每个合数只会被其<strong>最大非自身因数</strong>筛除</p><p>多说无益，先上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> numlist[<span class="number">100000</span>];</span><br><span class="line"><span class="comment">//0代表质数，1代表非质数</span></span><br><span class="line"><span class="type">int</span> prime[<span class="number">100000</span>], count;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (numlist[i]==<span class="number">0</span>) ans[++count] = i;<span class="comment">//是质数就先存入数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= count &amp;&amp; i*prime[j] &lt;= n; j++) &#123;</span><br><span class="line">numlist[prime[j] * i] = <span class="number">1</span>; <span class="comment">//每次让i乘已放入的质数，然后标记非质数</span></span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//但是如果i可以被该数整除就停止（关键）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再来分析下。</p><p>从表可以看出，我们会筛掉每个质数p的平方之后的p的倍数，但是如果i是p的倍数，那就说明它们的乘积那个合数的最大非自身因数不是i，所以不筛。</p><div class="table-container"><table><thead><tr><th><em>i</em> 的值</th><th style="text-align:left">质数表</th><th style="text-align:left">筛去的数</th></tr></thead><tbody><tr><td>2</td><td style="text-align:left">2</td><td style="text-align:left">4</td></tr><tr><td>3</td><td style="text-align:left">2, 3</td><td style="text-align:left">6, 9</td></tr><tr><td>4</td><td style="text-align:left">2, 3</td><td style="text-align:left">8</td></tr><tr><td>5</td><td style="text-align:left">2, 3, 5</td><td style="text-align:left">10, 15, 25</td></tr><tr><td>6</td><td style="text-align:left">2, 3, 5</td><td style="text-align:left">12</td></tr><tr><td>7</td><td style="text-align:left">2, 3, 5, 7</td><td style="text-align:left">14, 21, 28, 35</td></tr><tr><td>⋯</td><td style="text-align:left">⋯</td><td style="text-align:left">⋯</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何高效筛素数？让我们来看看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;生成一个1到n范围内的质数数组&lt;/p&gt;
&lt;h1 id=&quot;菜鸟这样做（枚举法）&quot;&gt;&lt;a href=&quot;#菜鸟这样做（枚举法）&quot; class=&quot;headerlink&quot; title=&quot;菜鸟这样做（枚</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="筛质数" scheme="https://www.kevinwu.cc/articles/tags/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础笔记</title>
    <link href="https://www.kevinwu.cc/posts/HtmlNotes/"/>
    <id>https://www.kevinwu.cc/posts/HtmlNotes/</id>
    <published>2022-12-20T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>这是我之前学习html做的一点笔记，是一些基础，非常简单好学。</p><h1 id="·网页基本信息"><a href="#·网页基本信息" class="headerlink" title="·网页基本信息"></a>·网页基本信息</h1><p>doctype声明</p><h3 id="meta描述性标签"><a href="#meta描述性标签" class="headerlink" title="meta描述性标签"></a>meta描述性标签</h3><p><img src="https://bed.kevinwu.cc/img/meta.webp" style="zoom:50%;" /> </p><hr><h1 id="·网页基本标签"><a href="#·网页基本标签" class="headerlink" title="·网页基本标签"></a>·网页基本标签</h1><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><p>h1~h6</p><h4 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h4><p>p</p><h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><p>br</p><h3 id="粗体斜体"><a href="#粗体斜体" class="headerlink" title="粗体斜体"></a>粗体斜体</h3><p>粗体b 斜体i</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>（&amp;        ;）</p><p>空格 nbsp</p><p>大于gt 小于lt</p><p>版权copy</p><hr><h1 id="·图像标签"><a href="#·图像标签" class="headerlink" title="·图像标签"></a>·图像标签</h1><p><img src="https://bed.kevinwu.cc/img/图像.webp" style="zoom: 25%;" /> </p><hr><h1 id="·超链接标签"><a href="#·超链接标签" class="headerlink" title="·超链接标签"></a>·超链接标签</h1><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p><img src="https://bed.kevinwu.cc/img/超链接.webp" style="zoom: 33%;" /></p><h3 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h3><p><strong>锚标记</strong> a id=“top”</p><p><strong>邮件链接</strong> mailto:</p><p><strong>QQ链接</strong> 上“qq推广”官网</p><hr><h1 id="·-概念-行内元素和块元素"><a href="#·-概念-行内元素和块元素" class="headerlink" title="·*概念:行内元素和块元素"></a>·*概念:行内元素和块元素</h1><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>独占一行的元素</p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>撑开宽度的元素</p><hr><h1 id="·列表"><a href="#·列表" class="headerlink" title="·列表"></a>·列表</h1><h3 id="有序列表、无序列表"><a href="#有序列表、无序列表" class="headerlink" title="有序列表、无序列表"></a>有序列表、无序列表</h3><p><img src="https://bed.kevinwu.cc/img/有序无序列表.webp" style="zoom: 33%;" /> </p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p><img src="https://bed.kevinwu.cc/img/自定义列表.webp" style="zoom: 50%;" /> </p><hr><h1 id="·表格标签"><a href="#·表格标签" class="headerlink" title="·表格标签"></a>·表格标签</h1><p><img src="https://bed.kevinwu.cc/img/表格.webp" style="zoom:33%;" /> </p><hr><h1 id="·媒体元素"><a href="#·媒体元素" class="headerlink" title="·媒体元素"></a>·媒体元素</h1><p><img src="https://bed.kevinwu.cc/img/媒体.webp" style="zoom: 33%;" /> </p><hr><h1 id="·页面结构"><a href="#·页面结构" class="headerlink" title="·页面结构"></a>·页面结构</h1><p><img src="https://bed.kevinwu.cc/img/页面结构.webp" style="zoom: 25%;" /> </p><hr><h1 id="·iframe内联框架"><a href="#·iframe内联框架" class="headerlink" title="·iframe内联框架"></a>·iframe内联框架</h1><p><img src="https://bed.kevinwu.cc/img/iframe.webp" style="zoom: 33%;" /></p><p>链接控制iframe窗口跳转</p><hr><h1 id="·表单"><a href="#·表单" class="headerlink" title="·表单"></a>·表单</h1><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><img src="https://bed.kevinwu.cc/img/表单.webp" style="zoom:33%;" /> </p><h3 id="元素表单格式"><a href="#元素表单格式" class="headerlink" title="元素表单格式"></a>元素表单格式</h3><p><img src="https://bed.kevinwu.cc/img/表单元素格式.webp" style="zoom: 25%;" /> </p><h3 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h3><p>text</p><p><img src="https://bed.kevinwu.cc/img/文本框.webp" style="zoom: 50%;" /> </p><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>radio</p><p><img src="https://bed.kevinwu.cc/img/单选框.webp" style="zoom: 50%;" /> </p><h3 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h3><p>checkbox</p><p><img src="https://bed.kevinwu.cc/img/多选框.webp" style="zoom: 50%;" /> </p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>button</p><p><img src="https://bed.kevinwu.cc/img/按钮.webp" style="zoom: 50%;" /> </p><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p><img src="https://bed.kevinwu.cc/img/下拉框.webp" style="zoom: 50%;" /> </p><h3 id="文本域、文件域"><a href="#文本域、文件域" class="headerlink" title="文本域、文件域"></a>文本域、文件域</h3><p><img src="https://bed.kevinwu.cc/img/文本文件域.webp" style="zoom: 33%;" /> </p><h3 id="滑块、搜索框"><a href="#滑块、搜索框" class="headerlink" title="滑块、搜索框"></a>滑块、搜索框</h3><p><img src="https://bed.kevinwu.cc/img/滑块、搜索框.webp" style="zoom: 33%;" /></p><h3 id="简单验证"><a href="#简单验证" class="headerlink" title="简单验证"></a>简单验证</h3><p><img src="https://bed.kevinwu.cc/img/功能表单.webp" style="zoom: 40%;" /> </p><h1 id="表单应用"><a href="#表单应用" class="headerlink" title="表单应用"></a>表单应用</h1><p>只读 readonly</p><p>禁用 disabled</p><p>隐藏 hidden</p><h1 id="表单初级验证"><a href="#表单初级验证" class="headerlink" title="表单初级验证"></a>表单初级验证</h1><p>placeholder 提示信息</p><p>required 必填</p><p>pattern 正则表达式（百度上搜索各种）</p><hr><p>图片来源于b站狂神说的html课程，推荐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我之前学习html做的一点笔记，是一些基础，非常简单好学。&lt;/p&gt;
&lt;h1 id=&quot;·网页基本信息&quot;&gt;&lt;a href=&quot;#·网页基本信息&quot; class=&quot;headerlink&quot; title=&quot;·网页基本信息&quot;&gt;&lt;/a&gt;·网页基本信息&lt;/h1&gt;&lt;p&gt;doctype声明&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.kevinwu.cc/articles/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://www.kevinwu.cc/articles/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>高精度运算</title>
    <link href="https://www.kevinwu.cc/posts/highPrecision/"/>
    <id>https://www.kevinwu.cc/posts/highPrecision/</id>
    <published>2022-12-19T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道每种数据类型的储存空间是有限的，如果我们要储存非常大的数可以用long long，更大则unsigned long long，再大就是有些编译器提供的_int128类型，但是要是比这还要大呢?我们就需要用到<strong>高精度运算</strong>，<strong>用数组来模拟非常大的整数</strong>。</p><p>我们只要定义一个数组，把数字分别放入数组序列中就可以储存非常大的数。</p><p>接下来我们看看怎么使用高精度运算。</p><p>（注意以下都是我个人的解法，不一定是最优解，借鉴学习即可）</p><h1 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h1><p><strong>题目：</strong>高精度加法，相当于 a+b problem，不用考虑负数。（<a href="https://www.luogu.com.cn/problem/P1601">洛谷P1601题</a>）</p><p>输入a和b，然后输出a+b，太简单了！但是，题目要求的是高精度加法，也就是说输入的a和b是非常大的，我们要使用高精度才能储存该数进行处理。</p><p>首先我们看看加法的竖式</p><p><img src="https://bed.kevinwu.cc/img/a+b.webp" style="zoom: 15%;" /></p><p>如果<strong>超过10</strong>就要向下一位<strong>进位</strong>，进位的数字和下一位的值相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//包含max函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> A[<span class="number">500</span>], B[<span class="number">500</span>], C[<span class="number">500</span>];<span class="comment">//这个定义必须放在主函数外!!!这样它才会初始化，我被这个坑惨了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> lena = a.<span class="built_in">length</span>(), lenb = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(lena, lenb);</span><br><span class="line">    <span class="comment">//把字符变成对应的数字，并倒序存入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lena; i++) A[i] = a[lena<span class="number">-1</span>-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenb; i++) B[i] = b[lenb<span class="number">-1</span>-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//相加并处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//相加</span></span><br><span class="line">        C[i] += A[i] + B[i];  </span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        C[i + <span class="number">1</span>] = C[i] / <span class="number">10</span>;</span><br><span class="line">        C[i] = C[i] % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果进位使得位数增加，我们就多输出一位</span></span><br><span class="line">    <span class="keyword">if</span> (C[len]) len++;</span><br><span class="line">    <span class="comment">//因为我们之前是倒序存入，所以现在倒序输出就又正了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span> ; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A*B"></a>A*B</h1><p><strong>题目：</strong>给出两个非负整数，求它们的乘积。每个非负整数不超过 10^2000^（<a href="https://www.luogu.com.cn/problem/P1303">洛谷P1303题</a>）</p><p>还是一样，看似是道弱智题，但是我们要注意输入值的范围，数值非常大，再加上要相乘，很容易就会超过我们数据类型范围，所以又要用到我们的高精度方法。</p><p>算乘法，我们就先复习下乘法竖式</p><p><img src="https://bed.kevinwu.cc/img/axb.webp" style="zoom: 15%;" /></p><p><strong>几个需要知道的点</strong></p><ul><li>和加法非常像，也是<strong>超10进位</strong>。</li><li>这里有个很重要的规律，我们<strong>倒着数</strong>，<strong>第一个数的i位乘第二个数的j位，它们的乘积会到第(i+j-1)位上</strong>。</li><li><strong>乘积的位数不超过两数的位数之和</strong>。</li></ul><p>知道了这个，我们就可以开始了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> A[<span class="number">5000</span>], B[<span class="number">5000</span>], C[<span class="number">5000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> lena = a.<span class="built_in">length</span>(), lenb = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//转化成对应数字并倒序存入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) A[i] = a[lena - i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenb; i++) B[i] = b[lenb - i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//计算乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) C[i + j - <span class="number">1</span>] += A[i] * B[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = lena + lenb;<span class="comment">//乘积的位数不超过两数的位数之和</span></span><br><span class="line">    <span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        C[i + <span class="number">1</span>] += C[i] / <span class="number">10</span>;</span><br><span class="line">        C[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉多余输出的位数</span></span><br><span class="line">    <span class="keyword">while</span> (!C[len]) len--;</span><br><span class="line">    <span class="comment">//特殊情况，乘积等于0</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) len = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len ; i &gt;= <span class="number">1</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="阶乘之和"><a href="#阶乘之和" class="headerlink" title="阶乘之和"></a>阶乘之和</h1><p><strong>题目描述</strong></p><p>用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。</p><p>其中 <code>!</code> 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。</p><p>输入n，输出s。（<a href="https://www.luogu.com.cn/problem/P1009">洛谷P1009题</a>）</p><p>这道题可以说是前两道题的结合。</p><p>这是我的解法，因为这道题较特殊，所以可以做到比前两道的代码还短，可能有点抽象，要仔细思考</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, A[<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;, B[<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;, n, j;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这个循环是外面的加法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//阶乘的相乘</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">            B[j] *= i;</span><br><span class="line">        <span class="comment">//阶乘的进位</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (B[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                B[j + <span class="number">1</span>] += B[j] / <span class="number">10</span>;</span><br><span class="line">                B[j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//每算完一个阶乘就加进结果并处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            A[j] += B[j];</span><br><span class="line">            <span class="keyword">if</span> (A[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                A[j + <span class="number">1</span>] += A[j] / <span class="number">10</span>;</span><br><span class="line">                A[j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除多余的位数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">100</span>; i &gt;= <span class="number">0</span> &amp;&amp; A[i] == <span class="number">0</span>; i--);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) cout&lt;&lt; A[j];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>灵活掌握，举一反三才能在程序竞赛中绽放自我。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道每种数据类型的储存空间是有限的，如果我们要储存非常大的数可以用long long，更大则unsigned long long，再大就是有些编译器提供的_int128类型，但是要是比这还要大呢?我们就需要用到&lt;strong&gt;高精度运算&lt;/strong&gt;，&lt;strong</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="高精度" scheme="https://www.kevinwu.cc/articles/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何求最大公因数？(辗转相除法)</title>
    <link href="https://www.kevinwu.cc/posts/gcd/"/>
    <id>https://www.kevinwu.cc/posts/gcd/</id>
    <published>2022-12-13T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>辗转相除法是一种求最大公因数的计算方法。</p><p>这种方法在编程中很常用，在数学计算中也可以用来求很复杂的最大公因数问题。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>题目：求最大公因数(36,14)</p><p>我们如何用辗转相除法做这道题呢？</p><script type="math/tex; mode=display">\displaylines{反复用除数除以余数直到除尽\\36{\div}14=2\dots8\\14{\div}8=1\dots6\\8{\div}6=1\dots2\\6{\div}2=3\\最后一个除数就是最大公约数，也就是2}</script><p>我们算出最大公约数(36,14)=2</p><p>到这里，我们就知道如何使用辗转相除法了。</p><p>但是，鲁迅曾说过“我们学公式必须得懂得原理”，我们明白了原理才能灵活运用</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>求最大公因数(a,b)</p><p>首先我们推出这几条式子</p><script type="math/tex; mode=display">\displaylines{a{\div}b=q\dots r \\a=bq+r \\r=a-bq}</script><p><strong>这是我们辗转法的原理</strong></p><script type="math/tex; mode=display">\displaylines{(a,b)=(b,r) \\a和b的最大公约数就等于b和r的最大公约数}</script><p>接下来让我们证明这条公式</p><script type="math/tex; mode=display">\displaylines{(1)设(a,b)=d\\那么a=dm,b=dn\\然后我们将其带入r=a-bq\\得r=d(m-nq)\\因为m,n,q都是整数，所以r是d的倍数，d是r的因数\\所以：只要是a,b的因数，就一定是d,r的约数\\}</script><script type="math/tex; mode=display">\displaylines{(2)设(b,r)=d\\和之前一样，那么b=dx,r=dy\\然后将其代入a=bq+r\\得a=d(xq+y)\\因为x,q,y都是整数，所以a是d的倍数，d是a的因数\\所以：只要是d,r的因数，就一定是a的因数\\}</script><p>这样，我们就得出(a,b)的因数和(b,r)的因数相同，它们的因数都相同，那么它们的最大公因数也就相同。</p><p>所以我们要求(a,b)的最大公因数，我们就通过可以求(b,r)的最大公因数来得到。</p><p><strong>现在我们再来看看开头的题</strong></p><p>题目：求最大公因数(36,14)</p><p>反复用(a,b)=(b,r)的方法</p><p>(36,14)=(14,8)=(8,6)=(6,2)</p><p>最后得到(6,2)，显而易见最大公约数是2</p><h1 id="写gcd函数"><a href="#写gcd函数" class="headerlink" title="写gcd函数"></a>写gcd函数</h1><p>接下来看看我们如何在C++中用辗转相除法写gcd函数</p><p>gcd函数就是用来求最大公因数的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (a % b != <span class="number">0</span>) <span class="comment">//a能被b整除时就终止循环</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> r = a % b;</span><br><span class="line">a = b;</span><br><span class="line">b = r; <span class="comment">//讲a换成除数b，b换成余数r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以直接用algorithm头文件中的gcd函数，</p><p>我们学会自己写是为了理解原理，提升思维，</p><p>自己写还可以在有特殊需求的时候更自定义化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;辗转相除法是一种求最大公因数的计算方法。&lt;/p&gt;
&lt;p&gt;这种方法在编程中很常用，在数学计算中也可以用来求很复杂的最大公因数问题。&lt;/p&gt;
&lt;h1 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何</summary>
      
    
    
    
    <category term="代码编程" scheme="https://www.kevinwu.cc/articles/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.kevinwu.cc/articles/tags/C/"/>
    
    <category term="算法" scheme="https://www.kevinwu.cc/articles/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数学" scheme="https://www.kevinwu.cc/articles/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="gcd" scheme="https://www.kevinwu.cc/articles/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>如何用Hexo搭建个人博客?</title>
    <link href="https://www.kevinwu.cc/posts/BuildBlog/"/>
    <id>https://www.kevinwu.cc/posts/BuildBlog/</id>
    <published>2022-12-07T16:00:00.000Z</published>
    <updated>2024-02-26T12:27:32.578Z</updated>
    
    <content type="html"><![CDATA[<p>我的个人博客搭建成功啦！</p><p>这篇文章会给大家分享我是如何从0开始搭建我的个人独立博客的</p><p>接下来我们开始吧</p><p><strong>文章比较精简，没有废话，不要跳步</strong></p><h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><p>首先我们需要到对应网站下载需要的工具</p><p><strong><a href="https://nodejs.org/en/">下载nodejs</a></strong></p><hr><p><em>(这篇文章里有修改nodejs缓存路径的教学:<a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">文章链接</a>，c盘战士可以不看)</em></p><p><strong><a href="https://git-scm.com/downloads">下载git</a></strong></p><hr><p>一直点确定就行，全部按它默认勾的</p><p><em>(这里有一篇详细安装教程<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">文章链接</a>，可以不看)</em></p><p>都是傻瓜式操作下载，可以不看教程，想调试下工具的话可以看看</p><p><strong>接下来我们测试下是否都下载成功</strong></p><p>管理员运行cmd，依次输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v（这个是node附带的）</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure><p><strong>下载hexo</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h1><p>成功下载好工具之后，我们开始搭建GitHub存储静态页面的仓库</p><p>首先注册/登入<a href="https://github.com/">Github</a></p><p>点击Create a new repository进入新建仓库页面</p><p>仓库名输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名.github.io</span><br></pre></td></tr></table></figure><p>勾选Public</p><p>勾选 Add a README file</p><p>拉到下面点击create创建</p><h1 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h1><p>进入任意文件夹，右键空白处然后点Git bash here,输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后敲4次Enter⌨️</p><p>然后进入C:\Users\用户名，在里面进入.ssh文件</p><p>用记事本打开里面的id_rsa.pub,全选复制里面的代码</p><p><strong>然后打开github</strong></p><p>进入用户设置，找到SSH keys</p><p>新建SSH keys，名称随意，在下面粘贴代码，</p><p>然后创建</p><p><strong>测试是否成功</strong></p><p>在git bash中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>回车，然后再输入yes</p><h1 id="本地生成博客内容"><a href="#本地生成博客内容" class="headerlink" title="本地生成博客内容"></a>本地生成博客内容</h1><p>在喜欢位置新建文件Blog，然后进入文件夹</p><p>右键空白处然后点Git bash here，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>然后管理员运行cmd，用cmd进入我们的Blog文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd操作指令：</span><br><span class="line">D:  (进入D盘)</span><br><span class="line">cd 文件夹名  (进入该文件夹)</span><br></pre></td></tr></table></figure><p>进入然后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo install</span><br></pre></td></tr></table></figure><p>成功后再回到Git bash</p><p>依次输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>（如果不成功的话就重复直到成功，因为国内与github连接不稳定）</p><p>现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了</p><p>然后关闭ctrl+c</p><h1 id="上线博客"><a href="#上线博客" class="headerlink" title="上线博客"></a>上线博客</h1><p>进入之前的Blog文件夹，用记事本打开_config.yml</p><p>拉到最下面将deploy后面的全删掉，复制粘贴这段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repository: </span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure><p>（每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！）</p><p>去github之前生成的仓库页面点code，复制https链接</p><p>将其粘贴到我们记事本中的repository：后面</p><p>然后保存退出</p><p><strong>和之前一样管理员运行cmd然后进入Blog文件夹</strong></p><p>安装自动部署发布工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后在Blog文件夹右键打开git bash，依次输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g（生成）</span><br><span class="line">hexo d（上传）</span><br></pre></td></tr></table></figure><p>然后在跳出来的窗口内进行登录</p><p>接下来我们就成功把本地内容上传到github了</p><p>上传成功以后，我们就算搭建好了！上自己的网址看看吧</p><p>网址是我们之前设的仓库名：用户名.github.io</p><h1 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h1><p>我们会发现我们的博客标题还是默认的hexo，整个页面是初始默认的，接下来我们对其进行修改</p><p>用记事本打开我们blog文件夹中的_config.yml文件</p><p>将#Site下面按自己的需求填上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">keywords: 关键词</span><br><span class="line">author: 站主</span><br><span class="line">language: 语言（可以填写zh-CN）</span><br><span class="line">timezone: 时区（可以填写Asia/Shanghai）</span><br></pre></td></tr></table></figure><p>然后保存</p><h1 id="如何上传文章"><a href="#如何上传文章" class="headerlink" title="如何上传文章"></a>如何上传文章</h1><p>我们在Blog文件夹中打开git bash,输入下方代码就可以生成新的文章文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><p>文章是.md格式，在我们的Blog文件夹中的source/_posts中</p><p>强烈推荐用Typora软件来编辑.md格式的文件</p><p>Typora官网：<a href="https://www.typoraio.cn/（89元终身使用，推荐正版）">https://www.typoraio.cn/（89元终身使用，推荐正版）</a></p><p>破解版奉上：<a href="https://kevinwu06.lanzout.com/iXkq30icv1ha">蓝奏云文件</a></p><p>然后我们用Typora软件打开该.md文件就可以开始写文章了</p><p>写好以后，我们还是一样打开git bash上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><hr><p>至此，我们就成功搭建好基本的博客了，剩下的就是对博客的一些优化和美化了。</p><p>如果想安装和我一样的<strong>butterfly主题</strong>的话接下来可以参考这个butterfly官方的教程</p><p><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly官方文档</a></p><p>有什么问题的话可以评论，我会尽快回复😁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的个人博客搭建成功啦！&lt;/p&gt;
&lt;p&gt;这篇文章会给大家分享我是如何从0开始搭建我的个人独立博客的&lt;/p&gt;
&lt;p&gt;接下来我们开始吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章比较精简，没有废话，不要跳步&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;准备工具&quot;&gt;&lt;a href=&quot;#准备</summary>
      
    
    
    
    <category term="博客相关" scheme="https://www.kevinwu.cc/articles/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="博客" scheme="https://www.kevinwu.cc/articles/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://www.kevinwu.cc/articles/tags/Hexo/"/>
    
  </entry>
  
</feed>
